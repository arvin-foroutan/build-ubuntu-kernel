From 572b8383a843a0ca8544533a25691e8390adf908 Mon Sep 17 00:00:00 2001
From: Oleksandr Natalenko <oleksandr@natalenko.name>
Date: Sun, 29 Aug 2021 00:29:48 +0200
Subject: [PATCH 14/33] update to git tree state

Signed-off-by: Oleksandr Natalenko <oleksandr@natalenko.name>
---
 Documentation/filesystems/index.rst |   1 +
 Documentation/filesystems/ntfs3.rst |   1 -
 MAINTAINERS                         |   2 +
 fs/ntfs3/attrib.c                   |  22 ++-
 fs/ntfs3/dir.c                      |  12 +-
 fs/ntfs3/file.c                     | 286 ++++++++++++++++++++--------
 fs/ntfs3/fslog.c                    |   5 +-
 fs/ntfs3/fsntfs.c                   |  11 +-
 fs/ntfs3/index.c                    |  16 +-
 fs/ntfs3/inode.c                    | 265 +++++++++++++-------------
 fs/ntfs3/namei.c                    | 139 +++++---------
 fs/ntfs3/ntfs_fs.h                  |  11 +-
 fs/ntfs3/super.c                    |  16 +-
 fs/ntfs3/xattr.c                    | 156 +++++++++++----
 14 files changed, 574 insertions(+), 369 deletions(-)

diff --git a/Documentation/filesystems/index.rst b/Documentation/filesystems/index.rst
index d4853cb91..de6a9060e 100644
--- a/Documentation/filesystems/index.rst
+++ b/Documentation/filesystems/index.rst
@@ -99,6 +99,7 @@ Documentation for filesystem implementations.
    nilfs2
    nfs/index
    ntfs
+   ntfs3
    ocfs2
    ocfs2-online-filecheck
    omfs
diff --git a/Documentation/filesystems/ntfs3.rst b/Documentation/filesystems/ntfs3.rst
index fb2906736..ffe9ea0c1 100644
--- a/Documentation/filesystems/ntfs3.rst
+++ b/Documentation/filesystems/ntfs3.rst
@@ -104,4 +104,3 @@ https://www.paragon-software.com/home/ntfs-linux-professional/
 
 almaz.alexandrovich@paragon-software.com
 	- Direct e-mail address for feedback and requests on the NTFS3 implementation.
-
diff --git a/MAINTAINERS b/MAINTAINERS
index dbcca71c8..551e2fa06 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -13074,8 +13074,10 @@ F:	fs/ntfs/
 
 NTFS3 FILESYSTEM
 M:	Konstantin Komarov <almaz.alexandrovich@paragon-software.com>
+L:	ntfs3@lists.linux.dev
 S:	Supported
 W:	http://www.paragon-software.com/
+T:	git https://github.com/Paragon-Software-Group/linux-ntfs3.git
 F:	Documentation/filesystems/ntfs3.rst
 F:	fs/ntfs3/
 
diff --git a/fs/ntfs3/attrib.c b/fs/ntfs3/attrib.c
index bca85e7b6..046dc57f7 100644
--- a/fs/ntfs3/attrib.c
+++ b/fs/ntfs3/attrib.c
@@ -1941,7 +1941,7 @@ int attr_collapse_range(struct ntfs_inode *ni, u64 vbo, u64 bytes)
 }
 
 /* not for normal files */
-int attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes)
+int attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes, u32 *frame_size)
 {
 	int err = 0;
 	struct runs_tree *run = &ni->file.run;
@@ -1951,6 +1951,7 @@ int attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes)
 	struct mft_inode *mi, *mi_b;
 	CLST svcn, evcn1, vcn, len, end, alen, dealloc;
 	u64 total_size, alloc_size;
+	u32 mask;
 
 	if (!bytes)
 		return 0;
@@ -1973,7 +1974,6 @@ int attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes)
 		return 0;
 	}
 
-	/* TODO: add support for normal files too */
 	if (!is_attr_ext(attr_b))
 		return -EOPNOTSUPP;
 
@@ -1985,8 +1985,22 @@ int attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes)
 		return 0;
 	}
 
-	if (vbo + bytes > alloc_size)
-		bytes = alloc_size - vbo;
+	mask = (sbi->cluster_size << attr_b->nres.c_unit) - 1;
+
+	bytes += vbo;
+	if (bytes > alloc_size)
+		bytes = alloc_size;
+	bytes -= vbo;
+
+	if ((vbo & mask) || (bytes & mask)) {
+		/* We have to zero a range(s)*/
+		if (frame_size == NULL) {
+			/* Caller insists range is aligned */
+			return -EINVAL;
+		}
+		*frame_size = mask + 1;
+		return E_NTFS_NOTALIGNED;
+	}
 
 	down_write(&ni->file.run_lock);
 	/*
diff --git a/fs/ntfs3/dir.c b/fs/ntfs3/dir.c
index 9ec6012c4..d36d7fbc2 100644
--- a/fs/ntfs3/dir.c
+++ b/fs/ntfs3/dir.c
@@ -585,10 +585,12 @@ bool dir_is_empty(struct inode *dir)
 	return is_empty;
 }
 
+// clang-format off
 const struct file_operations ntfs_dir_operations = {
-	.llseek = generic_file_llseek,
-	.read = generic_read_dir,
-	.iterate_shared = ntfs_readdir,
-	.fsync = generic_file_fsync,
-	.open = ntfs_file_open,
+	.llseek		= generic_file_llseek,
+	.read		= generic_read_dir,
+	.iterate_shared	= ntfs_readdir,
+	.fsync		= generic_file_fsync,
+	.open		= ntfs_file_open,
 };
+// clang-format on
diff --git a/fs/ntfs3/file.c b/fs/ntfs3/file.c
index 347baf674..59344985c 100644
--- a/fs/ntfs3/file.c
+++ b/fs/ntfs3/file.c
@@ -94,6 +94,7 @@ int ntfs_getattr(struct user_namespace *mnt_userns, const struct path *path,
 
 	stat->result_mask |= STATX_BTIME;
 	stat->btime = ni->i_crtime;
+	stat->blksize = ni->mi.sbi->cluster_size; /* 512, 1K, ..., 2M */
 
 	return 0;
 }
@@ -184,8 +185,6 @@ static int ntfs_extend_initialized_size(struct file *file,
 		cond_resched();
 	}
 
-	mark_inode_dirty(inode);
-
 	return 0;
 
 out:
@@ -195,10 +194,96 @@ static int ntfs_extend_initialized_size(struct file *file,
 	return err;
 }
 
+/*
+ * ntfs_zero_range
+ *
+ * Helper function for punch_hole.
+ * It zeroes a range [vbo, vbo_to)
+ */
+static int ntfs_zero_range(struct inode *inode, u64 vbo, u64 vbo_to)
+{
+	int err = 0;
+	struct address_space *mapping = inode->i_mapping;
+	u32 blocksize = 1 << inode->i_blkbits;
+	pgoff_t idx = vbo >> PAGE_SHIFT;
+	u32 z_start = vbo & (PAGE_SIZE - 1);
+	pgoff_t idx_end = (vbo_to + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	loff_t page_off;
+	struct buffer_head *head, *bh;
+	u32 bh_next, bh_off, z_end;
+	sector_t iblock;
+	struct page *page;
+
+	for (; idx < idx_end; idx += 1, z_start = 0) {
+		page_off = (loff_t)idx << PAGE_SHIFT;
+		z_end = (page_off + PAGE_SIZE) > vbo_to ? (vbo_to - page_off)
+							: PAGE_SIZE;
+		iblock = page_off >> inode->i_blkbits;
+
+		page = find_or_create_page(mapping, idx,
+					   mapping_gfp_constraint(mapping,
+								  ~__GFP_FS));
+		if (!page)
+			return -ENOMEM;
+
+		if (!page_has_buffers(page))
+			create_empty_buffers(page, blocksize, 0);
+
+		bh = head = page_buffers(page);
+		bh_off = 0;
+		do {
+			bh_next = bh_off + blocksize;
+
+			if (bh_next <= z_start || bh_off >= z_end)
+				continue;
+
+			if (!buffer_mapped(bh)) {
+				ntfs_get_block(inode, iblock, bh, 0);
+				/* unmapped? It's a hole - nothing to do */
+				if (!buffer_mapped(bh))
+					continue;
+			}
+
+			/* Ok, it's mapped. Make sure it's up-to-date */
+			if (PageUptodate(page))
+				set_buffer_uptodate(bh);
+
+			if (!buffer_uptodate(bh)) {
+				lock_buffer(bh);
+				bh->b_end_io = end_buffer_read_sync;
+				get_bh(bh);
+				submit_bh(REQ_OP_READ, 0, bh);
+
+				wait_on_buffer(bh);
+				if (!buffer_uptodate(bh)) {
+					unlock_page(page);
+					put_page(page);
+					err = -EIO;
+					goto out;
+				}
+			}
+
+			mark_buffer_dirty(bh);
+
+		} while (bh_off = bh_next, iblock += 1,
+			 head != (bh = bh->b_this_page));
+
+		zero_user_segment(page, z_start, z_end);
+
+		unlock_page(page);
+		put_page(page);
+		cond_resched();
+	}
+out:
+	mark_inode_dirty(inode);
+	return err;
+}
+
 /*
  * ntfs_sparse_cluster
  *
  * Helper function to zero a new allocated clusters
+ * NOTE: 512 <= cluster size <= 2M
  */
 void ntfs_sparse_cluster(struct inode *inode, struct page *page0, CLST vcn,
 			 CLST len)
@@ -233,13 +318,6 @@ void ntfs_sparse_cluster(struct inode *inode, struct page *page0, CLST vcn,
 		if ((from || PAGE_SIZE != to) &&
 		    likely(!page_has_buffers(page))) {
 			create_empty_buffers(page, blocksize, 0);
-			if (!page_has_buffers(page)) {
-				ntfs_inode_err(
-					inode,
-					"failed to allocate page buffers.");
-				/*err = -ENOMEM;*/
-				goto unlock_page;
-			}
 		}
 
 		if (page_has_buffers(page)) {
@@ -268,7 +346,6 @@ void ntfs_sparse_cluster(struct inode *inode, struct page *page0, CLST vcn,
 			set_page_dirty(page);
 		}
 
-unlock_page:
 		if (idx != idx0) {
 			unlock_page(page);
 			put_page(page);
@@ -286,57 +363,62 @@ static int ntfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	struct address_space *mapping = file->f_mapping;
 	struct inode *inode = mapping->host;
 	struct ntfs_inode *ni = ntfs_i(inode);
-	u64 to, from = ((u64)vma->vm_pgoff << PAGE_SHIFT);
+	u64 from = ((u64)vma->vm_pgoff << PAGE_SHIFT);
 	bool rw = vma->vm_flags & VM_WRITE;
 	int err;
 
 	if (is_encrypted(ni)) {
-		ntfs_inode_warn(inode,
-				"mmap is not supported for encrypted files");
-		err = -EOPNOTSUPP;
-		goto out;
+		ntfs_inode_warn(inode, "mmap encrypted not supported");
+		return -EOPNOTSUPP;
 	}
 
-	if (!rw)
-		goto do_map;
+	if (is_dedup(ni)) {
+		ntfs_inode_warn(inode, "mmap deduplicated not supported");
+		return -EOPNOTSUPP;
+	}
 
-	if (is_compressed(ni)) {
-		ntfs_inode_warn(
-			inode,
-			"mmap(write) is not supported for compressed files");
-		err = -EOPNOTSUPP;
-		goto out;
+	if (is_compressed(ni) && rw) {
+		ntfs_inode_warn(inode, "mmap(write) compressed not supported");
+		return -EOPNOTSUPP;
 	}
 
-	to = min_t(loff_t, i_size_read(inode),
-		   from + vma->vm_end - vma->vm_start);
+	if (rw) {
+		u64 to = min_t(loff_t, i_size_read(inode),
+			       from + vma->vm_end - vma->vm_start);
 
-	if (is_sparsed(ni)) {
-		/* allocate clusters for rw map */
-		struct ntfs_sb_info *sbi = inode->i_sb->s_fs_info;
-		CLST vcn, lcn, len;
-		CLST end = bytes_to_cluster(sbi, to);
-		bool new;
+		if (is_sparsed(ni)) {
+			/* allocate clusters for rw map */
+			struct ntfs_sb_info *sbi = inode->i_sb->s_fs_info;
+			CLST lcn, len;
+			CLST vcn = from >> sbi->cluster_bits;
+			CLST end = bytes_to_cluster(sbi, to);
+			bool new;
+
+			for (; vcn < end; vcn += len) {
+				err = attr_data_get_block(ni, vcn, 1, &lcn,
+							  &len, &new);
+				if (err)
+					goto out;
+
+				if (!new)
+					continue;
+				ntfs_sparse_cluster(inode, NULL, vcn, 1);
+			}
+		}
 
-		for (vcn = from >> sbi->cluster_bits; vcn < end; vcn += len) {
-			err = attr_data_get_block(ni, vcn, 1, &lcn, &len, &new);
+		if (ni->i_valid < to) {
+			if (!inode_trylock(inode)) {
+				err = -EAGAIN;
+				goto out;
+			}
+			err = ntfs_extend_initialized_size(file, ni,
+							   ni->i_valid, to);
+			inode_unlock(inode);
 			if (err)
 				goto out;
-			if (!new)
-				continue;
-			ntfs_sparse_cluster(inode, NULL, vcn, 1);
 		}
 	}
 
-	if (ni->i_valid < to) {
-		inode_lock(inode);
-		err = ntfs_extend_initialized_size(file, ni, ni->i_valid, to);
-		inode_unlock(inode);
-		if (err)
-			goto out;
-	}
-
-do_map:
 	err = generic_file_mmap(file, vma);
 out:
 	return err;
@@ -471,8 +553,11 @@ static long ntfs_fallocate(struct file *file, int mode, loff_t vbo, loff_t len)
 
 	/* Return error if mode is not supported */
 	if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |
-		     FALLOC_FL_COLLAPSE_RANGE))
+		     FALLOC_FL_COLLAPSE_RANGE)) {
+		ntfs_inode_warn(inode, "fallocate(0x%x) is not supported",
+				mode);
 		return -EOPNOTSUPP;
+	}
 
 	ntfs_set_state(sbi, NTFS_DIRTY_DIRTY);
 
@@ -486,19 +571,14 @@ static long ntfs_fallocate(struct file *file, int mode, loff_t vbo, loff_t len)
 	}
 
 	if (mode & FALLOC_FL_PUNCH_HOLE) {
+		u32 frame_size;
+		loff_t mask, vbo_a, end_a, tmp;
+
 		if (!(mode & FALLOC_FL_KEEP_SIZE)) {
 			err = -EINVAL;
 			goto out;
 		}
 
-		if (!is_sparsed(ni) && !is_compressed(ni)) {
-			ntfs_inode_warn(
-				inode,
-				"punch_hole only for sparsed/compressed files");
-			err = -EOPNOTSUPP;
-			goto out;
-		}
-
 		err = filemap_write_and_wait_range(inode->i_mapping, vbo,
 						   end - 1);
 		if (err)
@@ -509,11 +589,46 @@ static long ntfs_fallocate(struct file *file, int mode, loff_t vbo, loff_t len)
 		if (err)
 			goto out;
 
+		inode_dio_wait(inode);
+
 		truncate_pagecache(inode, vbo_down);
 
+		if (!is_sparsed(ni) && !is_compressed(ni)) {
+			/* normal file */
+			err = ntfs_zero_range(inode, vbo, end);
+			goto out;
+		}
+
 		ni_lock(ni);
-		err = attr_punch_hole(ni, vbo, len);
+		err = attr_punch_hole(ni, vbo, len, &frame_size);
 		ni_unlock(ni);
+		if (err != E_NTFS_NOTALIGNED)
+			goto out;
+
+		/* process not aligned punch */
+		mask = frame_size - 1;
+		vbo_a = (vbo + mask) & ~mask;
+		end_a = end & ~mask;
+
+		tmp = min(vbo_a, end);
+		if (tmp > vbo) {
+			err = ntfs_zero_range(inode, vbo, tmp);
+			if (err)
+				goto out;
+		}
+
+		if (vbo < end_a && end_a < end) {
+			err = ntfs_zero_range(inode, end_a, end);
+			if (err)
+				goto out;
+		}
+
+		/* Aligned punch_hole */
+		if (end_a > vbo_a) {
+			ni_lock(ni);
+			err = attr_punch_hole(ni, vbo_a, end_a - vbo_a, NULL);
+			ni_unlock(ni);
+		}
 	} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {
 		if (mode & ~FALLOC_FL_COLLAPSE_RANGE) {
 			err = -EINVAL;
@@ -538,6 +653,9 @@ static long ntfs_fallocate(struct file *file, int mode, loff_t vbo, loff_t len)
 		if (err)
 			goto out;
 
+		/* Wait for existing dio to complete */
+		inode_dio_wait(inode);
+
 		truncate_pagecache(inode, vbo_down);
 
 		ni_lock(ni);
@@ -583,9 +701,8 @@ static long ntfs_fallocate(struct file *file, int mode, loff_t vbo, loff_t len)
 				 * fallocate(1G) will zero 1G and this can be very long
 				 * xfstest 016/086 will fail without 'ntfs_sparse_cluster'
 				 */
-				/*ntfs_sparse_cluster(inode, NULL, vcn,
-				 *		    min(vcn_v - vcn, clen));
-				 */
+				ntfs_sparse_cluster(inode, NULL, vcn,
+						    min(vcn_v - vcn, clen));
 			}
 		}
 
@@ -599,13 +716,14 @@ static long ntfs_fallocate(struct file *file, int mode, loff_t vbo, loff_t len)
 		}
 	}
 
+out:
+	if (err == -EFBIG)
+		err = -ENOSPC;
+
 	if (!err) {
 		inode->i_ctime = inode->i_mtime = current_time(inode);
 		mark_inode_dirty(inode);
 	}
-out:
-	if (err == -EFBIG)
-		err = -ENOSPC;
 
 	inode_unlock(inode);
 	return err;
@@ -672,6 +790,8 @@ int ntfs3_setattr(struct user_namespace *mnt_userns, struct dentry *dentry,
 			ni->std_fa |= FILE_ATTRIBUTE_READONLY;
 	}
 
+	if (ia_valid & (ATTR_UID | ATTR_GID | ATTR_MODE))
+		ntfs_save_wsl_perm(inode);
 	mark_inode_dirty(inode);
 out:
 	return err;
@@ -910,10 +1030,10 @@ static ssize_t ntfs_compress_write(struct kiocb *iocb, struct iov_iter *from)
 			size_t cp, tail = PAGE_SIZE - off;
 
 			page = pages[ip];
-			cp = iov_iter_copy_from_user_atomic(page, from, off,
-							    min(tail, bytes));
+			cp = copy_page_from_iter_atomic(page, off,
+							min(tail, bytes), from);
 			flush_dcache_page(page);
-			iov_iter_advance(from, cp);
+
 			copied += cp;
 			bytes -= cp;
 			if (!bytes || !cp)
@@ -1102,29 +1222,31 @@ int ntfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 	return err;
 }
 
+// clang-format off
 const struct inode_operations ntfs_file_inode_operations = {
-	.getattr = ntfs_getattr,
-	.setattr = ntfs3_setattr,
-	.listxattr = ntfs_listxattr,
-	.permission = ntfs_permission,
-	.get_acl = ntfs_get_acl,
-	.set_acl = ntfs_set_acl,
-	.fiemap = ntfs_fiemap,
+	.getattr	= ntfs_getattr,
+	.setattr	= ntfs3_setattr,
+	.listxattr	= ntfs_listxattr,
+	.permission	= ntfs_permission,
+	.get_acl	= ntfs_get_acl,
+	.set_acl	= ntfs_set_acl,
+	.fiemap		= ntfs_fiemap,
 };
 
 const struct file_operations ntfs_file_operations = {
-	.llseek = generic_file_llseek,
-	.read_iter = ntfs_file_read_iter,
-	.write_iter = ntfs_file_write_iter,
+	.llseek		= generic_file_llseek,
+	.read_iter	= ntfs_file_read_iter,
+	.write_iter	= ntfs_file_write_iter,
 	.unlocked_ioctl = ntfs_ioctl,
 #ifdef CONFIG_COMPAT
-	.compat_ioctl = ntfs_compat_ioctl,
+	.compat_ioctl	= ntfs_compat_ioctl,
 #endif
-	.splice_read = generic_file_splice_read,
-	.mmap = ntfs_file_mmap,
-	.open = ntfs_file_open,
-	.fsync = generic_file_fsync,
-	.splice_write = iter_file_splice_write,
-	.fallocate = ntfs_fallocate,
-	.release = ntfs_file_release,
+	.splice_read	= generic_file_splice_read,
+	.mmap		= ntfs_file_mmap,
+	.open		= ntfs_file_open,
+	.fsync		= generic_file_fsync,
+	.splice_write	= iter_file_splice_write,
+	.fallocate	= ntfs_fallocate,
+	.release	= ntfs_file_release,
 };
+// clang-format on
diff --git a/fs/ntfs3/fslog.c b/fs/ntfs3/fslog.c
index 53da12252..397ba6a95 100644
--- a/fs/ntfs3/fslog.c
+++ b/fs/ntfs3/fslog.c
@@ -1544,8 +1544,9 @@ static u32 current_log_avail(struct ntfs_log *log)
 	 */
 	next_free_off = (log->l_flags & NTFSLOG_REUSE_TAIL)
 				? log->next_page + log->page_size
-			: log->next_page == log->first_page ? log->l_size
-							    : log->next_page;
+				: log->next_page == log->first_page
+					  ? log->l_size
+					  : log->next_page;
 
 	/* If the two offsets are the same then there is no available space */
 	if (oldest_off == next_free_off)
diff --git a/fs/ntfs3/fsntfs.c b/fs/ntfs3/fsntfs.c
index 327356b08..92140050f 100644
--- a/fs/ntfs3/fsntfs.c
+++ b/fs/ntfs3/fsntfs.c
@@ -990,7 +990,16 @@ int ntfs_set_state(struct ntfs_sb_info *sbi, enum NTFS_DIRTY_FLAGS dirty)
 
 	mark_inode_dirty(&ni->vfs_inode);
 	/*verify(!ntfs_update_mftmirr()); */
-	err = sync_inode_metadata(&ni->vfs_inode, 1);
+
+	/*
+	 * if we used wait=1, sync_inode_metadata waits for the io for the
+	 * inode to finish. It hangs when media is removed.
+	 * So wait=0 is sent down to sync_inode_metadata
+	 * and filemap_fdatawrite is used for the data blocks
+	 */
+	err = sync_inode_metadata(&ni->vfs_inode, 0);
+	if (!err)
+		err = filemap_fdatawrite(ni->vfs_inode.i_mapping);
 
 	return err;
 }
diff --git a/fs/ntfs3/index.c b/fs/ntfs3/index.c
index 931a7241e..6aa9540ec 100644
--- a/fs/ntfs3/index.c
+++ b/fs/ntfs3/index.c
@@ -2574,6 +2574,10 @@ int indx_delete_entry(struct ntfs_index *indx, struct ntfs_inode *ni,
 	return err;
 }
 
+/*
+ * Update duplicated information in directory entry
+ * 'dup' - info from MFT record
+ */
 int indx_update_dup(struct ntfs_inode *ni, struct ntfs_sb_info *sbi,
 		    const struct ATTR_FILE_NAME *fname,
 		    const struct NTFS_DUP_INFO *dup, int sync)
@@ -2598,7 +2602,7 @@ int indx_update_dup(struct ntfs_inode *ni, struct ntfs_sb_info *sbi,
 		goto out;
 	}
 
-	/* Find entries tree and on disk */
+	/* Find entry in directory */
 	err = indx_find(indx, ni, root, fname, fname_full_size(fname), sbi,
 			&diff, &e, fnd);
 	if (err)
@@ -2624,13 +2628,15 @@ int indx_update_dup(struct ntfs_inode *ni, struct ntfs_sb_info *sbi,
 	memcpy(&e_fname->dup, dup, sizeof(*dup));
 
 	if (fnd->level) {
+		/* directory entry in index */
 		err = indx_write(indx, ni, fnd->nodes[fnd->level - 1], sync);
-	} else if (sync) {
-		mi->dirty = true;
-		err = mi_write(mi, 1);
 	} else {
+		/* directory entry in directory MFT record */
 		mi->dirty = true;
-		mark_inode_dirty(&ni->vfs_inode);
+		if (sync)
+			err = mi_write(mi, 1);
+		else
+			mark_inode_dirty(&ni->vfs_inode);
 	}
 
 out:
diff --git a/fs/ntfs3/inode.c b/fs/ntfs3/inode.c
index 3e2056c95..bf51e2944 100644
--- a/fs/ntfs3/inode.c
+++ b/fs/ntfs3/inode.c
@@ -51,6 +51,9 @@ static struct inode *ntfs_read_mft(struct inode *inode,
 	struct runs_tree *run;
 
 	inode->i_op = NULL;
+	/* Setup 'uid' and 'gid' */
+	inode->i_uid = sbi->options.fs_uid;
+	inode->i_gid = sbi->options.fs_gid;
 
 	err = mi_init(&ni->mi, sbi, ino);
 	if (err)
@@ -354,8 +357,15 @@ static struct inode *ntfs_read_mft(struct inode *inode,
 
 	case ATTR_EA_INFO:
 		if (!attr->name_len &&
-		    resident_data_ex(attr, sizeof(struct EA_INFO)))
+		    resident_data_ex(attr, sizeof(struct EA_INFO))) {
 			ni->ni_flags |= NI_FLAG_EA;
+			/*
+			 * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode
+			 */
+			inode->i_mode = mode;
+			ntfs_get_wsl_perm(inode);
+			mode = inode->i_mode;
+		}
 		goto next_attr;
 
 	default:
@@ -387,15 +397,13 @@ static struct inode *ntfs_read_mft(struct inode *inode,
 	if (std5->fa & FILE_ATTRIBUTE_READONLY)
 		mode &= ~0222;
 
-	/* Setup 'uid' and 'gid' */
-	inode->i_uid = sbi->options.fs_uid;
-	inode->i_gid = sbi->options.fs_gid;
-
 	if (!names) {
 		err = -EINVAL;
 		goto out;
 	}
 
+	set_nlink(inode, names);
+
 	if (S_ISDIR(mode)) {
 		ni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;
 
@@ -404,7 +412,6 @@ static struct inode *ntfs_read_mft(struct inode *inode,
 		 * included in enumeration.
 		 * Usually a hard links to directories are disabled
 		 */
-		set_nlink(inode, 1);
 		inode->i_op = &ntfs_dir_inode_operations;
 		inode->i_fop = &ntfs_dir_operations;
 		ni->i_valid = 0;
@@ -413,19 +420,18 @@ static struct inode *ntfs_read_mft(struct inode *inode,
 		inode->i_op = &ntfs_link_inode_operations;
 		inode->i_fop = NULL;
 		inode_nohighmem(inode); // ??
-		set_nlink(inode, names);
 	} else if (S_ISREG(mode)) {
 		ni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;
-
-		set_nlink(inode, names);
-
 		inode->i_op = &ntfs_file_inode_operations;
 		inode->i_fop = &ntfs_file_operations;
 		inode->i_mapping->a_ops =
 			is_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;
-
 		if (ino != MFT_REC_MFT)
 			init_rwsem(&ni->file.run_lock);
+	} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||
+		   S_ISSOCK(mode)) {
+		inode->i_op = &ntfs_special_inode_operations;
+		init_special_inode(inode, mode, inode->i_rdev);
 	} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&
 		   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {
 		/* Records in $Extend are not a files or general directories */
@@ -568,7 +574,6 @@ static noinline int ntfs_get_block_vbo(struct inode *inode, u64 vbo,
 		if (!create) {
 			if (bh->b_size > bytes)
 				bh->b_size = bytes;
-
 			return 0;
 		}
 		WARN_ON(1);
@@ -594,15 +599,16 @@ static noinline int ntfs_get_block_vbo(struct inode *inode, u64 vbo,
 			set_buffer_new(bh);
 	} else if (create) {
 		/*normal write*/
-		if (vbo >= valid) {
+		if (bytes > bh->b_size)
+			bytes = bh->b_size;
+
+		if (vbo >= valid)
 			set_buffer_new(bh);
-			if (bytes > bh->b_size)
-				bytes = bh->b_size;
+
+		if (vbo + bytes > valid) {
 			ni->i_valid = vbo + bytes;
 			mark_inode_dirty(inode);
 		}
-	} else if (valid >= inode->i_size) {
-		/* normal read of normal file*/
 	} else if (vbo >= valid) {
 		/* read out of valid data*/
 		/* should never be here 'cause already checked */
@@ -616,19 +622,22 @@ static noinline int ntfs_get_block_vbo(struct inode *inode, u64 vbo,
 		/*
 		 * read across valid size: vbo < valid && valid < vbo + block_size
 		 */
-		u32 voff = valid - vbo;
-
-		bh->b_size = bytes = block_size;
-		off = vbo & (PAGE_SIZE - 1);
-		set_bh_page(bh, page, off);
-		ll_rw_block(REQ_OP_READ, 0, 1, &bh);
-		wait_on_buffer(bh);
-		/* Uhhuh. Read error. Complain and punt. */
-		if (!buffer_uptodate(bh)) {
-			err = -EIO;
-			goto out;
+		bytes = block_size;
+
+		if (page) {
+			u32 voff = valid - vbo;
+
+			bh->b_size = block_size;
+			off = vbo & (PAGE_SIZE - 1);
+			set_bh_page(bh, page, off);
+			ll_rw_block(REQ_OP_READ, 0, 1, &bh);
+			wait_on_buffer(bh);
+			if (!buffer_uptodate(bh)) {
+				err = -EIO;
+				goto out;
+			}
+			zero_user_segment(page, off + voff, off + block_size);
 		}
-		zero_user_segment(page, off + voff, off + block_size);
 	}
 
 	if (bh->b_size > bytes)
@@ -746,12 +755,9 @@ static ssize_t ntfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
 	struct address_space *mapping = file->f_mapping;
 	struct inode *inode = mapping->host;
 	struct ntfs_inode *ni = ntfs_i(inode);
-	size_t count = iov_iter_count(iter);
 	loff_t vbo = iocb->ki_pos;
-	loff_t end = vbo + count;
+	loff_t end;
 	int wr = iov_iter_rw(iter) & WRITE;
-	const struct iovec *iov = iter->iov;
-	unsigned long nr_segs = iter->nr_segs;
 	loff_t valid;
 	ssize_t ret;
 
@@ -764,51 +770,25 @@ static ssize_t ntfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
 	ret = blockdev_direct_IO(iocb, inode, iter,
 				 wr ? ntfs_get_block_direct_IO_W
 				    : ntfs_get_block_direct_IO_R);
+
+	if (ret <= 0)
+		goto out;
+
+	end = vbo + ret;
 	valid = ni->i_valid;
 	if (wr) {
-		if (ret <= 0)
-			goto out;
-
-		vbo += ret;
-		if (vbo > valid && !S_ISBLK(inode->i_mode)) {
-			ni->i_valid = vbo;
+		if (end > valid && !S_ISBLK(inode->i_mode)) {
+			ni->i_valid = end;
 			mark_inode_dirty(inode);
 		}
 	} else if (vbo < valid && valid < end) {
 		/* fix page */
-		unsigned long uaddr = ~0ul;
-		struct page *page;
-		long i, npages;
-		size_t dvbo = valid - vbo;
-		size_t off = 0;
-
-		/*Find user address*/
-		for (i = 0; i < nr_segs; i++) {
-			if (off <= dvbo && dvbo < off + iov[i].iov_len) {
-				uaddr = (unsigned long)iov[i].iov_base + dvbo -
-					off;
-				break;
-			}
-			off += iov[i].iov_len;
-		}
-
-		if (uaddr == ~0ul)
-			goto fix_error;
-
-		npages = get_user_pages_unlocked(uaddr, 1, &page, FOLL_WRITE);
-
-		if (npages <= 0)
-			goto fix_error;
-
-		zero_user_segment(page, valid & (PAGE_SIZE - 1), PAGE_SIZE);
-		put_page(page);
+		iov_iter_revert(iter, end - valid);
+		iov_iter_zero(end - valid, iter);
 	}
 
 out:
 	return ret;
-fix_error:
-	ntfs_inode_warn(inode, "file garbage at 0x%llx", valid);
-	goto out;
 }
 
 int ntfs_set_size(struct inode *inode, u64 new_size)
@@ -1180,7 +1160,7 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 				struct inode *dir, struct dentry *dentry,
 				const struct cpu_str *uni, umode_t mode,
 				dev_t dev, const char *symname, u32 size,
-				int excl, struct ntfs_fnd *fnd)
+				struct ntfs_fnd *fnd)
 {
 	int err;
 	struct super_block *sb = dir->i_sb;
@@ -1203,20 +1183,13 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 	struct INDEX_ROOT *root, *dir_root;
 	struct NTFS_DE *e, *new_de = NULL;
 	struct REPARSE_DATA_BUFFER *rp = NULL;
-	bool is_dir = S_ISDIR(mode);
-	bool is_link = S_ISLNK(mode);
 	bool rp_inserted = false;
-	bool is_sp = S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||
-		     S_ISSOCK(mode);
-
-	if (is_sp)
-		return ERR_PTR(-EOPNOTSUPP);
 
 	dir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);
 	if (!dir_root)
 		return ERR_PTR(-EINVAL);
 
-	if (is_dir) {
+	if (S_ISDIR(mode)) {
 		/* use parent's directory attributes */
 		fa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |
 		     FILE_ATTRIBUTE_ARCHIVE;
@@ -1227,7 +1200,7 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 		 */
 		if (dir->i_ino == MFT_REC_ROOT)
 			fa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
-	} else if (is_link) {
+	} else if (S_ISLNK(mode)) {
 		/* It is good idea that link should be the same type (file/dir) as target */
 		fa = FILE_ATTRIBUTE_REPARSE_POINT;
 
@@ -1255,14 +1228,19 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 		 *		path_put(&path);
 		 *	}
 		 */
-	} else if (sbi->options.sparse) {
-		/* sparsed regular file, cause option 'sparse' */
-		fa = FILE_ATTRIBUTE_SPARSE_FILE | FILE_ATTRIBUTE_ARCHIVE;
-	} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {
-		/* compressed regular file, if parent is compressed */
-		fa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;
+	} else if (S_ISREG(mode)) {
+		if (sbi->options.sparse) {
+			/* sparsed regular file, cause option 'sparse' */
+			fa = FILE_ATTRIBUTE_SPARSE_FILE |
+			     FILE_ATTRIBUTE_ARCHIVE;
+		} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {
+			/* compressed regular file, if parent is compressed */
+			fa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;
+		} else {
+			/* regular file, default attributes */
+			fa = FILE_ATTRIBUTE_ARCHIVE;
+		}
 	} else {
-		/* regular file, default attributes */
 		fa = FILE_ATTRIBUTE_ARCHIVE;
 	}
 
@@ -1291,6 +1269,7 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 		goto out3;
 	}
 	inode = &ni->vfs_inode;
+	inode_init_owner(mnt_userns, inode, dir, mode);
 
 	inode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =
 		current_time(inode);
@@ -1414,7 +1393,7 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 		e = Add2Ptr(root, sizeof(struct INDEX_ROOT));
 		e->size = cpu_to_le16(sizeof(struct NTFS_DE));
 		e->flags = NTFS_IE_LAST;
-	} else if (is_link) {
+	} else if (S_ISLNK(mode)) {
 		/*
 		 * symlink to file
 		 * Create empty resident data attribute
@@ -1429,38 +1408,55 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 		attr->res.data_off = SIZEOF_RESIDENT_LE;
 	} else {
 		/*
-		 * regular file
+		 * regular file or node
 		 */
 		attr->type = ATTR_DATA;
 		attr->id = cpu_to_le16(aid++);
-		/* Create empty non resident data attribute */
-		attr->non_res = 1;
-		attr->nres.evcn = cpu_to_le64(-1ll);
-		if (fa & FILE_ATTRIBUTE_SPARSE_FILE) {
-			attr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);
-			attr->name_off = SIZEOF_NONRESIDENT_EX_LE;
-			attr->flags = ATTR_FLAG_SPARSED;
-			asize = SIZEOF_NONRESIDENT_EX + 8;
-		} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {
-			attr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);
-			attr->name_off = SIZEOF_NONRESIDENT_EX_LE;
-			attr->flags = ATTR_FLAG_COMPRESSED;
-			attr->nres.c_unit = COMPRESSION_UNIT;
-			asize = SIZEOF_NONRESIDENT_EX + 8;
+
+		if (S_ISREG(mode)) {
+			/* Create empty non resident data attribute */
+			attr->non_res = 1;
+			attr->nres.evcn = cpu_to_le64(-1ll);
+			if (fa & FILE_ATTRIBUTE_SPARSE_FILE) {
+				attr->size =
+					cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);
+				attr->name_off = SIZEOF_NONRESIDENT_EX_LE;
+				attr->flags = ATTR_FLAG_SPARSED;
+				asize = SIZEOF_NONRESIDENT_EX + 8;
+			} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {
+				attr->size =
+					cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);
+				attr->name_off = SIZEOF_NONRESIDENT_EX_LE;
+				attr->flags = ATTR_FLAG_COMPRESSED;
+				attr->nres.c_unit = COMPRESSION_UNIT;
+				asize = SIZEOF_NONRESIDENT_EX + 8;
+			} else {
+				attr->size =
+					cpu_to_le32(SIZEOF_NONRESIDENT + 8);
+				attr->name_off = SIZEOF_NONRESIDENT_LE;
+				asize = SIZEOF_NONRESIDENT + 8;
+			}
+			attr->nres.run_off = attr->name_off;
 		} else {
-			attr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);
-			attr->name_off = SIZEOF_NONRESIDENT_LE;
-			asize = SIZEOF_NONRESIDENT + 8;
+			/* Create empty resident data attribute */
+			attr->size = cpu_to_le32(SIZEOF_RESIDENT);
+			attr->name_off = SIZEOF_RESIDENT_LE;
+			if (fa & FILE_ATTRIBUTE_SPARSE_FILE)
+				attr->flags = ATTR_FLAG_SPARSED;
+			else if (fa & FILE_ATTRIBUTE_COMPRESSED)
+				attr->flags = ATTR_FLAG_COMPRESSED;
+			attr->res.data_off = SIZEOF_RESIDENT_LE;
+			asize = SIZEOF_RESIDENT;
+			ni->ni_flags |= NI_FLAG_RESIDENT;
 		}
-		attr->nres.run_off = attr->name_off;
 	}
 
-	if (is_dir) {
+	if (S_ISDIR(mode)) {
 		ni->ni_flags |= NI_FLAG_DIR;
 		err = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);
 		if (err)
 			goto out4;
-	} else if (is_link) {
+	} else if (S_ISLNK(mode)) {
 		rp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);
 
 		if (IS_ERR(rp)) {
@@ -1547,36 +1543,32 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 	/* Update current directory record */
 	mark_inode_dirty(dir);
 
-	/* Fill vfs inode fields */
-	inode->i_uid = sbi->options.uid ? sbi->options.fs_uid : current_fsuid();
-	inode->i_gid = sbi->options.gid		 ? sbi->options.fs_gid
-		       : (dir->i_mode & S_ISGID) ? dir->i_gid
-						 : current_fsgid();
 	inode->i_generation = le16_to_cpu(rec->seq);
 
 	dir->i_mtime = dir->i_ctime = inode->i_atime;
 
-	if (is_dir) {
+	if (S_ISDIR(mode)) {
 		if (dir->i_mode & S_ISGID)
 			mode |= S_ISGID;
 		inode->i_op = &ntfs_dir_inode_operations;
 		inode->i_fop = &ntfs_dir_operations;
-	} else if (is_link) {
+	} else if (S_ISLNK(mode)) {
 		inode->i_op = &ntfs_link_inode_operations;
 		inode->i_fop = NULL;
 		inode->i_mapping->a_ops = &ntfs_aops;
-	} else {
+	} else if (S_ISREG(mode)) {
 		inode->i_op = &ntfs_file_inode_operations;
 		inode->i_fop = &ntfs_file_operations;
 		inode->i_mapping->a_ops =
 			is_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;
 		init_rwsem(&ni->file.run_lock);
+	} else {
+		inode->i_op = &ntfs_special_inode_operations;
+		init_special_inode(inode, mode, dev);
 	}
 
-	inode->i_mode = mode;
-
 #ifdef CONFIG_NTFS3_FS_POSIX_ACL
-	if (!is_link && (sb->s_flags & SB_POSIXACL)) {
+	if (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {
 		err = ntfs_init_acl(mnt_userns, inode, dir);
 		if (err)
 			goto out6;
@@ -1596,6 +1588,7 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 	/* call 'd_instantiate' after inode->i_op is set but before finish_open */
 	d_instantiate(dentry, inode);
 
+	ntfs_save_wsl_perm(inode);
 	mark_inode_dirty(inode);
 	mark_inode_dirty(dir);
 
@@ -1612,7 +1605,7 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 		ntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);
 
 out5:
-	if (is_dir || run_is_empty(&ni->file.run))
+	if (S_ISDIR(mode) || run_is_empty(&ni->file.run))
 		goto out4;
 
 	run_deallocate(sbi, &ni->file.run, false);
@@ -2007,28 +2000,30 @@ static const char *ntfs_get_link(struct dentry *de, struct inode *inode,
 	return ret;
 }
 
+// clang-format off
 const struct inode_operations ntfs_link_inode_operations = {
-	.get_link = ntfs_get_link,
-	.setattr = ntfs3_setattr,
-	.listxattr = ntfs_listxattr,
-	.permission = ntfs_permission,
-	.get_acl = ntfs_get_acl,
-	.set_acl = ntfs_set_acl,
+	.get_link	= ntfs_get_link,
+	.setattr	= ntfs3_setattr,
+	.listxattr	= ntfs_listxattr,
+	.permission	= ntfs_permission,
+	.get_acl	= ntfs_get_acl,
+	.set_acl	= ntfs_set_acl,
 };
 
 const struct address_space_operations ntfs_aops = {
-	.readpage = ntfs_readpage,
-	.readahead = ntfs_readahead,
-	.writepage = ntfs_writepage,
-	.writepages = ntfs_writepages,
-	.write_begin = ntfs_write_begin,
-	.write_end = ntfs_write_end,
-	.direct_IO = ntfs_direct_IO,
-	.bmap = ntfs_bmap,
+	.readpage	= ntfs_readpage,
+	.readahead	= ntfs_readahead,
+	.writepage	= ntfs_writepage,
+	.writepages	= ntfs_writepages,
+	.write_begin	= ntfs_write_begin,
+	.write_end	= ntfs_write_end,
+	.direct_IO	= ntfs_direct_IO,
+	.bmap		= ntfs_bmap,
 	.set_page_dirty = __set_page_dirty_buffers,
 };
 
 const struct address_space_operations ntfs_aops_cmpr = {
-	.readpage = ntfs_readpage,
-	.readahead = ntfs_readahead,
+	.readpage	= ntfs_readpage,
+	.readahead	= ntfs_readahead,
 };
+// clang-format on
diff --git a/fs/ntfs3/namei.c b/fs/ntfs3/namei.c
index f5db12cd3..b1ccd6617 100644
--- a/fs/ntfs3/namei.c
+++ b/fs/ntfs3/namei.c
@@ -111,7 +111,28 @@ static int ntfs_create(struct user_namespace *mnt_userns, struct inode *dir,
 	ni_lock_dir(ni);
 
 	inode = ntfs_create_inode(mnt_userns, dir, dentry, NULL, S_IFREG | mode,
-				  0, NULL, 0, excl, NULL);
+				  0, NULL, 0, NULL);
+
+	ni_unlock(ni);
+
+	return IS_ERR(inode) ? PTR_ERR(inode) : 0;
+}
+
+/*
+ * ntfs_mknod
+ *
+ * inode_operations::mknod
+ */
+static int ntfs_mknod(struct user_namespace *mnt_userns, struct inode *dir,
+		      struct dentry *dentry, umode_t mode, dev_t rdev)
+{
+	struct ntfs_inode *ni = ntfs_i(dir);
+	struct inode *inode;
+
+	ni_lock_dir(ni);
+
+	inode = ntfs_create_inode(mnt_userns, dir, dentry, NULL, mode, rdev,
+				  NULL, 0, NULL);
 
 	ni_unlock(ni);
 
@@ -194,7 +215,7 @@ static int ntfs_symlink(struct user_namespace *mnt_userns, struct inode *dir,
 	ni_lock_dir(ni);
 
 	inode = ntfs_create_inode(mnt_userns, dir, dentry, NULL, S_IFLNK | 0777,
-				  0, symname, size, 0, NULL);
+				  0, symname, size, NULL);
 
 	ni_unlock(ni);
 
@@ -215,7 +236,7 @@ static int ntfs_mkdir(struct user_namespace *mnt_userns, struct inode *dir,
 	ni_lock_dir(ni);
 
 	inode = ntfs_create_inode(mnt_userns, dir, dentry, NULL, S_IFDIR | mode,
-				  0, NULL, -1, 0, NULL);
+				  0, NULL, 0, NULL);
 
 	ni_unlock(ni);
 
@@ -466,76 +487,6 @@ static int ntfs_rename(struct user_namespace *mnt_userns, struct inode *old_dir,
 	return err;
 }
 
-/*
- * ntfs_atomic_open
- *
- * inode_operations::atomic_open
- */
-static int ntfs_atomic_open(struct inode *dir, struct dentry *dentry,
-			    struct file *file, u32 flags, umode_t mode)
-{
-	int err;
-	bool excl = !!(flags & O_EXCL);
-	struct inode *inode;
-	struct ntfs_fnd *fnd = NULL;
-	struct ntfs_inode *ni = ntfs_i(dir);
-	struct dentry *d = NULL;
-	struct cpu_str *uni = __getname();
-
-	if (!uni)
-		return -ENOMEM;
-
-	err = ntfs_nls_to_utf16(ni->mi.sbi, dentry->d_name.name,
-				dentry->d_name.len, uni, NTFS_NAME_LEN,
-				UTF16_HOST_ENDIAN);
-	if (err < 0)
-		goto out;
-
-	ni_lock_dir(ni);
-
-	if (d_in_lookup(dentry)) {
-		fnd = fnd_get();
-		if (!fnd) {
-			err = -ENOMEM;
-			goto out1;
-		}
-
-		d = d_splice_alias(dir_search_u(dir, uni, fnd), dentry);
-		if (IS_ERR(d)) {
-			err = PTR_ERR(d);
-			d = NULL;
-			goto out2;
-		}
-
-		if (d)
-			dentry = d;
-	}
-
-	if (!(flags & O_CREAT) || d_really_is_positive(dentry)) {
-		err = finish_no_open(file, d);
-		goto out2;
-	}
-
-	file->f_mode |= FMODE_CREATED;
-
-	/*fnd contains tree's path to insert to*/
-	/* TODO: init_user_ns? */
-	inode = ntfs_create_inode(&init_user_ns, dir, dentry, uni, mode, 0,
-				  NULL, 0, excl, fnd);
-	err = IS_ERR(inode) ? PTR_ERR(inode)
-			    : finish_open(file, dentry, ntfs_file_open);
-	dput(d);
-
-out2:
-	fnd_put(fnd);
-out1:
-	ni_unlock(ni);
-out:
-	__putname(uni);
-
-	return err;
-}
-
 struct dentry *ntfs3_get_parent(struct dentry *child)
 {
 	struct inode *inode = d_inode(child);
@@ -558,21 +509,31 @@ struct dentry *ntfs3_get_parent(struct dentry *child)
 	return ERR_PTR(-ENOENT);
 }
 
+// clang-format off
 const struct inode_operations ntfs_dir_inode_operations = {
-	.lookup = ntfs_lookup,
-	.create = ntfs_create,
-	.link = ntfs_link,
-	.unlink = ntfs_unlink,
-	.symlink = ntfs_symlink,
-	.mkdir = ntfs_mkdir,
-	.rmdir = ntfs_rmdir,
-	.rename = ntfs_rename,
-	.permission = ntfs_permission,
-	.get_acl = ntfs_get_acl,
-	.set_acl = ntfs_set_acl,
-	.setattr = ntfs3_setattr,
-	.getattr = ntfs_getattr,
-	.listxattr = ntfs_listxattr,
-	.atomic_open = ntfs_atomic_open,
-	.fiemap = ntfs_fiemap,
+	.lookup		= ntfs_lookup,
+	.create		= ntfs_create,
+	.link		= ntfs_link,
+	.unlink		= ntfs_unlink,
+	.symlink	= ntfs_symlink,
+	.mkdir		= ntfs_mkdir,
+	.rmdir		= ntfs_rmdir,
+	.mknod		= ntfs_mknod,
+	.rename		= ntfs_rename,
+	.permission	= ntfs_permission,
+	.get_acl	= ntfs_get_acl,
+	.set_acl	= ntfs_set_acl,
+	.setattr	= ntfs3_setattr,
+	.getattr	= ntfs_getattr,
+	.listxattr	= ntfs_listxattr,
+	.fiemap		= ntfs_fiemap,
+};
+
+const struct inode_operations ntfs_special_inode_operations = {
+	.setattr	= ntfs3_setattr,
+	.getattr	= ntfs_getattr,
+	.listxattr	= ntfs_listxattr,
+	.get_acl	= ntfs_get_acl,
+	.set_acl	= ntfs_set_acl,
 };
+// clang-format on
diff --git a/fs/ntfs3/ntfs_fs.h b/fs/ntfs3/ntfs_fs.h
index 5e1dd628d..0c3ac89c3 100644
--- a/fs/ntfs3/ntfs_fs.h
+++ b/fs/ntfs3/ntfs_fs.h
@@ -18,6 +18,9 @@
 #define E_NTFS_FIXUP			555
 /* ntfs specific error code about resident->nonresident*/
 #define E_NTFS_NONRESIDENT		556
+/* ntfs specific error code about punch hole*/
+#define E_NTFS_NOTALIGNED		557
+
 
 /* sbi->flags */
 #define NTFS_FLAGS_NODISCARD		0x00000001
@@ -408,7 +411,7 @@ int attr_is_frame_compressed(struct ntfs_inode *ni, struct ATTRIB *attr,
 int attr_allocate_frame(struct ntfs_inode *ni, CLST frame, size_t compr_size,
 			u64 new_valid);
 int attr_collapse_range(struct ntfs_inode *ni, u64 vbo, u64 bytes);
-int attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes);
+int attr_punch_hole(struct ntfs_inode *ni, u64 vbo, u64 bytes, u32 *frame_size);
 
 /* functions from attrlist.c*/
 void al_destroy(struct ntfs_inode *ni);
@@ -648,7 +651,7 @@ struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,
 				struct inode *dir, struct dentry *dentry,
 				const struct cpu_str *uni, umode_t mode,
 				dev_t dev, const char *symname, u32 size,
-				int excl, struct ntfs_fnd *fnd);
+				struct ntfs_fnd *fnd);
 int ntfs_link_inode(struct inode *inode, struct dentry *dentry);
 int ntfs_unlink_inode(struct inode *dir, const struct dentry *dentry);
 void ntfs_evict_inode(struct inode *inode);
@@ -662,6 +665,7 @@ int fill_name_de(struct ntfs_sb_info *sbi, void *buf, const struct qstr *name,
 struct dentry *ntfs3_get_parent(struct dentry *child);
 
 extern const struct inode_operations ntfs_dir_inode_operations;
+extern const struct inode_operations ntfs_special_inode_operations;
 
 /* globals from record.c */
 int mi_get(struct ntfs_sb_info *sbi, CLST rno, struct mft_inode **mi);
@@ -799,6 +803,9 @@ int ntfs_permission(struct user_namespace *mnt_userns, struct inode *inode,
 ssize_t ntfs_listxattr(struct dentry *dentry, char *buffer, size_t size);
 extern const struct xattr_handler *ntfs_xattr_handlers[];
 
+int ntfs_save_wsl_perm(struct inode *inode);
+void ntfs_get_wsl_perm(struct inode *inode);
+
 /* globals from lznt.c */
 struct lznt *get_lznt_ctx(int level);
 size_t compress_lznt(const void *uncompressed, size_t uncompressed_size,
diff --git a/fs/ntfs3/super.c b/fs/ntfs3/super.c
index c56343124..6be13e256 100644
--- a/fs/ntfs3/super.c
+++ b/fs/ntfs3/super.c
@@ -17,8 +17,10 @@
  * ni  - ntfs inode              - extends linux inode. consists of one or more mft inodes
  * index - unit inside directory - 2K, 4K, <=page size, does not depend on cluster size
  *
- * TODO: Implement
+ * WSL - Windows Subsystem for Linux
  * https://docs.microsoft.com/en-us/windows/wsl/file-permissions
+ * It stores uid/gid/mode/dev in xattr
+ *
  */
 
 #include <linux/backing-dev.h>
@@ -1413,13 +1415,15 @@ static struct dentry *ntfs_mount(struct file_system_type *fs_type, int flags,
 	return mount_bdev(fs_type, flags, dev_name, data, ntfs_fill_super);
 }
 
+// clang-format off
 static struct file_system_type ntfs_fs_type = {
-	.owner = THIS_MODULE,
-	.name = "ntfs3",
-	.mount = ntfs_mount,
-	.kill_sb = kill_block_super,
-	.fs_flags = FS_REQUIRES_DEV,
+	.owner		= THIS_MODULE,
+	.name		= "ntfs3",
+	.mount		= ntfs_mount,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV | FS_ALLOW_IDMAP,
 };
+// clang-format on
 
 static int __init init_ntfs_fs(void)
 {
diff --git a/fs/ntfs3/xattr.c b/fs/ntfs3/xattr.c
index 759df507c..98871c895 100644
--- a/fs/ntfs3/xattr.c
+++ b/fs/ntfs3/xattr.c
@@ -314,8 +314,19 @@ static noinline int ntfs_set_ea(struct inode *inode, const char *name,
 			goto out;
 		}
 
-		/* Remove current xattr */
 		ea = Add2Ptr(ea_all, off);
+
+		/*
+		 * Check simple case when we try to insert xattr with the same value
+		 * e.g. ntfs_save_wsl_perm
+		 */
+		if (val_size && le16_to_cpu(ea->elength) == val_size &&
+		    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {
+			/* xattr already contains the required value */
+			goto out;
+		}
+
+		/* Remove current xattr */
 		if (ea->flags & FILE_NEED_EA)
 			le16_add_cpu(&ea_info.count, -1);
 
@@ -330,8 +341,10 @@ static noinline int ntfs_set_ea(struct inode *inode, const char *name,
 
 		ea_info.size = cpu_to_le32(size);
 
-		if ((flags & XATTR_REPLACE) && !val_size)
+		if ((flags & XATTR_REPLACE) && !val_size) {
+			/* remove xattr */
 			goto update_ea;
+		}
 	} else {
 		if (flags & XATTR_REPLACE) {
 			err = -ENODATA;
@@ -564,7 +577,6 @@ static noinline int ntfs_set_acl_ex(struct user_namespace *mnt_userns,
 				 * traditional file mode permission bits
 				 */
 				acl = NULL;
-				goto out;
 			}
 		}
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
@@ -582,29 +594,27 @@ static noinline int ntfs_set_acl_ex(struct user_namespace *mnt_userns,
 		return -EINVAL;
 	}
 
-	if (!acl)
-		goto out;
-
-	size = posix_acl_xattr_size(acl->a_count);
-	value = ntfs_malloc(size);
-	if (!value)
-		return -ENOMEM;
-
-	err = posix_acl_to_xattr(mnt_userns, acl, value, size);
-	if (err)
-		goto out;
-
-	err = ntfs_set_ea(inode, name, name_len, value, size, 0, locked);
-	if (err)
-		goto out;
+	if (!acl) {
+		size = 0;
+		value = NULL;
+	} else {
+		size = posix_acl_xattr_size(acl->a_count);
+		value = ntfs_malloc(size);
+		if (!value)
+			return -ENOMEM;
 
-	inode->i_flags &= ~S_NOSEC;
+		err = posix_acl_to_xattr(mnt_userns, acl, value, size);
+		if (err < 0)
+			goto out;
+	}
 
-out:
+	err = ntfs_set_ea(inode, name, name_len, value, size,
+			  acl ? 0 : XATTR_REPLACE, locked);
 	if (!err)
 		set_cached_acl(inode, type, acl);
 
-	kfree(value);
+out:
+	ntfs_free(value);
 
 	return err;
 }
@@ -656,17 +666,18 @@ static int ntfs_xattr_set_acl(struct user_namespace *mnt_userns,
 	if (!inode_owner_or_capable(mnt_userns, inode))
 		return -EPERM;
 
-	if (!value)
-		return 0;
-
-	acl = posix_acl_from_xattr(mnt_userns, value, size);
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
+	if (!value) {
+		acl = NULL;
+	} else {
+		acl = posix_acl_from_xattr(mnt_userns, value, size);
+		if (IS_ERR(acl))
+			return PTR_ERR(acl);
 
-	if (acl) {
-		err = posix_acl_valid(mnt_userns, acl);
-		if (err)
-			goto release_and_out;
+		if (acl) {
+			err = posix_acl_valid(mnt_userns, acl);
+			if (err)
+				goto release_and_out;
+		}
 	}
 
 	err = ntfs_set_acl(mnt_userns, inode, acl, type);
@@ -1011,9 +1022,8 @@ static noinline int ntfs_setxattr(const struct xattr_handler *handler,
 	    (name_len == sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1 &&
 	     !memcmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,
 		     sizeof(XATTR_NAME_POSIX_ACL_DEFAULT)))) {
-		/* TODO: init_user_ns? */
 		err = ntfs_xattr_set_acl(
-			&init_user_ns, inode,
+			mnt_userns, inode,
 			name_len == sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1
 				? ACL_TYPE_ACCESS
 				: ACL_TYPE_DEFAULT,
@@ -1028,19 +1038,91 @@ static noinline int ntfs_setxattr(const struct xattr_handler *handler,
 	return err;
 }
 
+/*
+ * ntfs_save_wsl_perm
+ *
+ * save uid/gid/mode in xattr
+ */
+int ntfs_save_wsl_perm(struct inode *inode)
+{
+	int err;
+	__le32 value;
+
+	value = cpu_to_le32(i_uid_read(inode));
+	err = ntfs_set_ea(inode, "$LXUID", sizeof("$LXUID") - 1, &value,
+			  sizeof(value), 0, 0);
+	if (err)
+		goto out;
+
+	value = cpu_to_le32(i_gid_read(inode));
+	err = ntfs_set_ea(inode, "$LXGID", sizeof("$LXGID") - 1, &value,
+			  sizeof(value), 0, 0);
+	if (err)
+		goto out;
+
+	value = cpu_to_le32(inode->i_mode);
+	err = ntfs_set_ea(inode, "$LXMOD", sizeof("$LXMOD") - 1, &value,
+			  sizeof(value), 0, 0);
+	if (err)
+		goto out;
+
+	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
+		value = cpu_to_le32(inode->i_rdev);
+		err = ntfs_set_ea(inode, "$LXDEV", sizeof("$LXDEV") - 1, &value,
+				  sizeof(value), 0, 0);
+		if (err)
+			goto out;
+	}
+
+out:
+	/* In case of error should we delete all WSL xattr? */
+	return err;
+}
+
+/*
+ * ntfs_get_wsl_perm
+ *
+ * get uid/gid/mode from xattr
+ * it is called from ntfs_iget5->ntfs_read_mft
+ */
+void ntfs_get_wsl_perm(struct inode *inode)
+{
+	size_t sz;
+	__le32 value[3];
+
+	if (ntfs_get_ea(inode, "$LXUID", sizeof("$LXUID") - 1, &value[0],
+			sizeof(value[0]), &sz) == sizeof(value[0]) &&
+	    ntfs_get_ea(inode, "$LXGID", sizeof("$LXGID") - 1, &value[1],
+			sizeof(value[1]), &sz) == sizeof(value[1]) &&
+	    ntfs_get_ea(inode, "$LXMOD", sizeof("$LXMOD") - 1, &value[2],
+			sizeof(value[2]), &sz) == sizeof(value[2])) {
+		i_uid_write(inode, (uid_t)le32_to_cpu(value[0]));
+		i_gid_write(inode, (gid_t)le32_to_cpu(value[1]));
+		inode->i_mode = le32_to_cpu(value[2]);
+
+		if (ntfs_get_ea(inode, "$LXDEV", sizeof("$$LXDEV") - 1,
+				&value[0], sizeof(value),
+				&sz) == sizeof(value[0])) {
+			inode->i_rdev = le32_to_cpu(value[0]);
+		}
+	}
+}
+
 static bool ntfs_xattr_user_list(struct dentry *dentry)
 {
 	return true;
 }
 
+// clang-format off
 static const struct xattr_handler ntfs_xattr_handler = {
-	.prefix = "",
-	.get = ntfs_getxattr,
-	.set = ntfs_setxattr,
-	.list = ntfs_xattr_user_list,
+	.prefix	= "",
+	.get	= ntfs_getxattr,
+	.set	= ntfs_setxattr,
+	.list	= ntfs_xattr_user_list,
 };
 
 const struct xattr_handler *ntfs_xattr_handlers[] = {
 	&ntfs_xattr_handler,
 	NULL,
 };
+// clang-format on
-- 
2.33.0

