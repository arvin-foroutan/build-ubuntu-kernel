From 0db0fe733a709e0b71054d50889f8bd4a6970b52 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Fri, 22 Oct 2021 12:48:01 +0200
Subject: [PATCH 14/15] lrng-5.15: update to the latest git HEAD

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 drivers/char/lrng/Kconfig              |  74 ++++++++++-
 drivers/char/lrng/Makefile             |   5 +-
 drivers/char/lrng/lrng_aux.c           |   2 +-
 drivers/char/lrng/lrng_chacha20.c      |   2 +-
 drivers/char/lrng/lrng_drng.c          |  11 +-
 drivers/char/lrng/lrng_es_archrandom.c | 167 ++++++++++++++++++++++---
 drivers/char/lrng/lrng_es_aux.c        |  30 ++++-
 drivers/char/lrng/lrng_es_irq.c        |  65 +++++++---
 drivers/char/lrng/lrng_es_jent.c       |  11 +-
 drivers/char/lrng/lrng_es_mgr.c        |   8 +-
 drivers/char/lrng/lrng_interfaces.c    |  30 +++--
 drivers/char/lrng/lrng_internal.h      |  85 +++++++++----
 drivers/char/lrng/lrng_proc.c          |  48 ++++---
 drivers/char/lrng/lrng_selftest.c      |  81 +++++++-----
 drivers/char/lrng/lrng_switch.c        |   2 +-
 include/linux/lrng.h                   |   2 +-
 16 files changed, 480 insertions(+), 143 deletions(-)

diff --git a/drivers/char/lrng/Kconfig b/drivers/char/lrng/Kconfig
index de50abaf5..6f969ac6e 100644
--- a/drivers/char/lrng/Kconfig
+++ b/drivers/char/lrng/Kconfig
@@ -59,9 +59,39 @@ menu "Entropy Source Configuration"
 
 comment "Interrupt Entropy Source"
 
+config LRNG_IRQ
+	bool "Enable Interrupt Entropy Source as LRNG Seed Source"
+	default y
+	help
+	  The LRNG models an entropy source based on the timing of the
+	  occurrence of interrupts. Enable this option to enable this
+	  IRQ entropy source.
+
+	  The IRQ entropy source is triggered every time an interrupt
+	  arrives and thus causes the interrupt handler to execute
+	  slightly longer. Disabling the IRQ entropy source implies
+	  that the performance penalty on the interrupt handler added
+	  by the LRNG is eliminated. Yet, this entropy source is
+	  considered to be the internal entropy source of the LRNG.
+	  Thus, only disable it if you ensured that other entropy
+	  sources are available that supply the LRNG with entropy.
+
+	  If you disable the IRQ entropy source, you MUST ensure
+	  one or more entropy sources collectively have the
+	  capability to deliver sufficient entropy with one invocation
+	  at a rate compliant to the security strength of the DRNG
+	  (usually 256 bits of entropy). In addition, if those
+	  entropy sources do not deliver sufficient entropy during
+	  first request, the reseed must be triggered from user
+	  space or kernel space when sufficient entropy is considered
+	  to be present.
+
+	  If unsure, say Y.
+
 choice
 	prompt "Continuous entropy compression boot time setting"
 	default LRNG_CONTINUOUS_COMPRESSION_ENABLED
+	depends on LRNG_IRQ
 	help
 	  Select the default behavior of the interrupt entropy source
 	  continuous compression operation.
@@ -97,6 +127,7 @@ config LRNG_ENABLE_CONTINUOUS_COMPRESSION
 
 config LRNG_SWITCHABLE_CONTINUOUS_COMPRESSION
 	bool "Runtime-switchable continuous entropy compression"
+	depends on LRNG_IRQ
 	help
 	  Per default, the interrupt entropy source continuous
 	  compression operation behavior is hard-wired into the kernel.
@@ -111,6 +142,7 @@ config LRNG_SWITCHABLE_CONTINUOUS_COMPRESSION
 choice
 	prompt "LRNG Entropy Collection Pool Size"
 	default LRNG_COLLECTION_SIZE_1024
+	depends on LRNG_IRQ
 	help
 	  Select the size of the LRNG entropy collection pool
 	  storing data for the interrupt entropy source without
@@ -166,6 +198,7 @@ config LRNG_COLLECTION_SIZE
 
 config LRNG_HEALTH_TESTS
 	bool "Enable interrupt entropy source online health tests"
+	depends on LRNG_IRQ
 	help
 	  The online health tests applied to the interrupt entropy
 	  source validate the noise source at runtime for fatal
@@ -223,6 +256,7 @@ config LRNG_APT_CUTOFF
 
 config LRNG_IRQ_ENTROPY_RATE
 	int "Interrupt Entropy Source Entropy Rate"
+	depends on LRNG_IRQ
 	range 256 4294967295
 	default 256
 	help
@@ -255,6 +289,7 @@ config LRNG_JENT
 
 config LRNG_JENT_ENTROPY_RATE
 	int "Jitter RNG Entropy Source Entropy Rate"
+	depends on LRNG_JENT
 	range 0 256
 	default 16
 	help
@@ -263,13 +298,33 @@ config LRNG_JENT_ENTROPY_RATE
 	  LRNG enforces the limit that this value must be in the range
 	  between 0 and 256.
 
-	  In order to disable the Jitter RNG entropy source, the option
-	  has to be set to 0.
+	  When configuring this value to 0, the Jitter RNG entropy source
+	  will provide 256 bits of data without being credited to contain
+	  entropy.
 
 comment "CPU Entropy Source"
 
+config LRNG_CPU
+	bool "Enable CPU Entropy Source as LRNG Seed Source"
+	default y
+	help
+	  Current CPUs commonly contain entropy sources which can be
+	  used to seed the LRNG. For example, the Intel RDSEED
+	  instruction, or the POWER DARN instruction will be sourced
+	  to seed the LRNG if this option is enabled.
+
+	  Note, if this option is enabled and the underlying CPU
+	  does not offer such entropy source, the LRNG will automatically
+	  detect this and ignore the hardware.
+
+config LRNG_CPU_FULL_ENT_MULTIPLIER
+	int
+	default 1 if !LRNG_TEST_CPU_ES_COMPRESSION
+	default 123 if LRNG_TEST_CPU_ES_COMPRESSION
+
 config LRNG_CPU_ENTROPY_RATE
 	int "CPU Entropy Source Entropy Rate"
+	depends on LRNG_CPU
 	range 0 256
 	default 8
 	help
@@ -278,8 +333,9 @@ config LRNG_CPU_ENTROPY_RATE
 	  enforces the limit that this value must be in the range between
 	  0 and 256.
 
-	  In order to disable the CPU entropy source, the option has to
-	  be set to 0.
+	  When configuring this value to 0, the CPU entropy source will
+	  provide 256 bits of data without being credited to contain
+	  entropy.
 
 	  Note, this option is overwritten when the option
 	  CONFIG_RANDOM_TRUST_CPU is set.
@@ -488,6 +544,16 @@ config LRNG_RUNTIME_MAX_WO_RESEED_CONFIG
 	  operations without a reseed that has full entropy. The
 	  interface is lrng_drng.max_wo_reseed.
 
+config LRNG_TEST_CPU_ES_COMPRESSION
+	bool "Force CPU ES compression operation"
+	help
+	  When enabling this option, the CPU ES compression operation
+	  is forced by setting an arbitrary value > 1 for the data
+	  multiplier even when the CPU ES would deliver full entropy.
+	  This allows testing of the compression operation. It
+	  therefore forces to pull more data from the CPU ES
+	  than what may be required.
+
 config LRNG_TESTING
 	bool
 	default y if (LRNG_RAW_HIRES_ENTROPY || LRNG_RAW_JIFFIES_ENTROPY ||LRNG_RAW_IRQ_ENTROPY || LRNG_RAW_IRQFLAGS_ENTROPY || LRNG_RAW_RETIP_ENTROPY || LRNG_RAW_REGS_ENTROPY || LRNG_RAW_ARRAY || LRNG_IRQ_PERF || LRNG_ACVT_HASH)
diff --git a/drivers/char/lrng/Makefile b/drivers/char/lrng/Makefile
index 623813764..e4f7f9702 100644
--- a/drivers/char/lrng/Makefile
+++ b/drivers/char/lrng/Makefile
@@ -4,12 +4,13 @@
 #
 
 obj-y				+= lrng_es_mgr.o lrng_aux.o \
-				   lrng_es_irq.o lrng_es_archrandom.o \
 				   lrng_drng.o lrng_chacha20.o \
 				   lrng_interfaces.o lrng_es_aux.o
 
-obj-$(CONFIG_NUMA)		+= lrng_numa.o
+obj-$(CONFIG_LRNG_IRQ)		+= lrng_es_irq.o
 obj-$(CONFIG_SYSCTL)		+= lrng_proc.o
+obj-$(CONFIG_NUMA)		+= lrng_numa.o
+obj-$(CONFIG_LRNG_CPU)		+= lrng_es_archrandom.o
 obj-$(CONFIG_LRNG_DRNG_SWITCH)	+= lrng_switch.o
 obj-$(CONFIG_LRNG_KCAPI_HASH)	+= lrng_kcapi_hash.o
 obj-$(CONFIG_LRNG_DRBG)		+= lrng_drbg.o
diff --git a/drivers/char/lrng/lrng_aux.c b/drivers/char/lrng/lrng_aux.c
index a970bbc87..e3b994f6e 100644
--- a/drivers/char/lrng/lrng_aux.c
+++ b/drivers/char/lrng/lrng_aux.c
@@ -103,7 +103,7 @@ void invalidate_batched_entropy(void)
 	}
 }
 
-/**
+/*
  * randomize_page - Generate a random, page aligned address
  * @start:	The smallest acceptable address the caller will take.
  * @range:	The size of the area, starting at @start, within which the
diff --git a/drivers/char/lrng/lrng_chacha20.c b/drivers/char/lrng/lrng_chacha20.c
index ebbd67b60..51f693c29 100644
--- a/drivers/char/lrng/lrng_chacha20.c
+++ b/drivers/char/lrng/lrng_chacha20.c
@@ -31,7 +31,7 @@ struct chacha20_state {
  */
 struct chacha20_state chacha20 __latent_entropy;
 
-/**
+/*
  * Update of the ChaCha20 state by either using an unused buffer part or by
  * generating one ChaCha20 block which is half of the state of the ChaCha20.
  * The block is XORed into the key part of the state. This shall ensure
diff --git a/drivers/char/lrng/lrng_drng.c b/drivers/char/lrng/lrng_drng.c
index 701fb26c6..1ab533263 100644
--- a/drivers/char/lrng/lrng_drng.c
+++ b/drivers/char/lrng/lrng_drng.c
@@ -293,7 +293,14 @@ void lrng_drng_force_reseed(void)
 	struct lrng_drng **lrng_drng = lrng_drng_instances();
 	u32 node;
 
-	if (!lrng_drng) {
+	/*
+	 * If the initial DRNG is over the reseed threshold, allow a forced
+	 * reseed only for the initial DRNG as this is the fallback for all. It
+	 * must be kept seeded before all others to keep the LRNG operational.
+	 */
+	if (!lrng_drng ||
+	    (atomic_read_u32(&lrng_drng_init.requests_since_fully_seeded) >
+	     LRNG_DRNG_RESEED_THRESH)) {
 		lrng_drng_init.force_reseed = lrng_drng_init.fully_seeded;
 		pr_debug("force reseed of initial DRNG\n");
 		return;
@@ -310,7 +317,7 @@ void lrng_drng_force_reseed(void)
 	lrng_drng_atomic.force_reseed = lrng_drng_atomic.fully_seeded;
 }
 
-/**
+/*
  * lrng_drng_get() - Get random data out of the DRNG which is reseeded
  * frequently.
  *
diff --git a/drivers/char/lrng/lrng_es_archrandom.c b/drivers/char/lrng/lrng_es_archrandom.c
index ae87fa9ba..6965f9b8a 100644
--- a/drivers/char/lrng/lrng_es_archrandom.c
+++ b/drivers/char/lrng/lrng_es_archrandom.c
@@ -7,6 +7,8 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <crypto/hash.h>
+#include <linux/lrng.h>
 #include <linux/random.h>
 
 #include "lrng_internal.h"
@@ -25,7 +27,7 @@ static u32 archrandom = LRNG_ARCHRANDOM_DEFAULT_STRENGTH;
 #endif
 #ifdef CONFIG_LRNG_RUNTIME_ES_CONFIG
 module_param(archrandom, uint, 0644);
-MODULE_PARM_DESC(archrandom, "Entropy in bits of 256 data bits from CPU noise source (e.g. RDRAND)");
+MODULE_PARM_DESC(archrandom, "Entropy in bits of 256 data bits from CPU noise source (e.g. RDSEED)");
 #endif
 
 static int __init lrng_parse_trust_cpu(char *arg)
@@ -53,18 +55,9 @@ u32 lrng_archrandom_entropylevel(u32 requested_bits)
 	return lrng_fast_noise_entropylevel(archrandom, requested_bits);
 }
 
-/**
- * lrng_get_arch() - Get CPU noise source entropy
- *
- * @outbuf: buffer to store entropy of size LRNG_DRNG_SECURITY_STRENGTH_BYTES
- *
- * Return:
- * * > 0 on success where value provides the added entropy in bits
- * *   0 if no fast source was available
- */
-u32 lrng_get_arch(u8 *outbuf, u32 requested_bits)
+static u32 lrng_get_arch_data(u8 *outbuf, u32 requested_bits)
 {
-	u32 i, ent_bits = lrng_archrandom_entropylevel(requested_bits);
+	u32 i;
 
 	/* operate on full blocks */
 	BUILD_BUG_ON(LRNG_DRNG_SECURITY_STRENGTH_BYTES % sizeof(unsigned long));
@@ -73,9 +66,6 @@ u32 lrng_get_arch(u8 *outbuf, u32 requested_bits)
 	/* ensure we have aligned buffers */
 	BUILD_BUG_ON(LRNG_KCAPI_ALIGN % sizeof(unsigned long));
 
-	if (!ent_bits)
-		return 0;
-
 	for (i = 0; i < (requested_bits >> 3);
 	     i += sizeof(unsigned long)) {
 		if (!arch_get_random_seed_long((unsigned long *)(outbuf + i)) &&
@@ -85,7 +75,152 @@ u32 lrng_get_arch(u8 *outbuf, u32 requested_bits)
 		}
 	}
 
-	pr_debug("obtained %u bits of entropy from CPU RNG noise source\n",
+	return requested_bits;
+}
+
+static u32 inline lrng_get_arch_data_compress(u8 *outbuf, u32 requested_bits,
+					      u32 data_multiplier)
+{
+	SHASH_DESC_ON_STACK(shash, NULL);
+	const struct lrng_crypto_cb *crypto_cb;
+	struct lrng_drng *drng = lrng_drng_init_instance();
+	unsigned long flags;
+	u32 ent_bits = 0, i, partial_bits = 0,
+	    full_bits = requested_bits * data_multiplier;
+	void *hash;
+
+	/* Calculate oversampling for SP800-90C */
+	if (lrng_sp80090c_compliant()) {
+		/* Complete amount of bits to be pulled */
+		full_bits += CONFIG_LRNG_OVERSAMPLE_ES_BITS * data_multiplier;
+		/* Full blocks that will be pulled */
+		data_multiplier = full_bits / requested_bits;
+		/* Partial block in bits to be pulled */
+		partial_bits = full_bits - (data_multiplier * requested_bits);
+	}
+
+	lrng_hash_lock(drng, &flags);
+	crypto_cb = drng->crypto_cb;
+	hash = drng->hash;
+
+	if (crypto_cb->lrng_hash_init(shash, hash))
+		goto out;
+
+	/* Hash all data from the CPU entropy source */
+	for (i = 0; i < data_multiplier; i++) {
+		ent_bits = lrng_get_arch_data(outbuf, requested_bits);
+		if (!ent_bits)
+			goto out;
+
+		if (crypto_cb->lrng_hash_update(shash, outbuf, ent_bits >> 3))
+			goto err;
+	}
+
+	/* Hash partial block, if applicable */
+	ent_bits = lrng_get_arch_data(outbuf, partial_bits);
+	if (ent_bits &&
+	    crypto_cb->lrng_hash_update(shash, outbuf, ent_bits >> 3))
+		goto err;
+
+	pr_debug("pulled %u bits from CPU RNG entropy source\n", full_bits);
+
+	/* Generate the compressed data to be returned to the caller */
+	ent_bits = crypto_cb->lrng_hash_digestsize(hash) << 3;
+	if (requested_bits < ent_bits) {
+		u8 digest[LRNG_MAX_DIGESTSIZE];
+
+		if (crypto_cb->lrng_hash_final(shash, digest))
+			goto err;
+
+		/* Truncate output data to requested size */
+		memcpy(outbuf, digest, requested_bits >> 3);
+		memzero_explicit(digest, crypto_cb->lrng_hash_digestsize(hash));
+		ent_bits = requested_bits;
+	} else {
+		if (crypto_cb->lrng_hash_final(shash, outbuf))
+			goto err;
+	}
+
+out:
+	crypto_cb->lrng_hash_desc_zero(shash);
+	lrng_hash_unlock(drng, flags);
+	return ent_bits;
+
+err:
+	ent_bits = 0;
+	goto out;
+}
+
+/*
+ * If CPU entropy source requires does not return full entropy, return the
+ * multiplier of how much data shall be sampled from it.
+ */
+static u32 lrng_arch_multiplier(void)
+{
+	static u32 data_multiplier = 0;
+
+	if (data_multiplier > 0) {
+		return data_multiplier;
+	} else {
+		unsigned long v;
+
+		if (IS_ENABLED(CONFIG_X86) && !arch_get_random_seed_long(&v)) {
+			/*
+			 * Intel SPEC: pulling 512 blocks from RDRAND ensures
+			 * one reseed making it logically equivalent to RDSEED.
+			 */
+			data_multiplier = 512;
+		} else if (IS_ENABLED(CONFIG_PPC)) {
+			/*
+			 * PowerISA defines DARN to deliver at least 0.5 bits of
+			 * entropy per data bit.
+			 */
+			data_multiplier = 2;
+		} else {
+			/* CPU provides full entropy */
+			data_multiplier = CONFIG_LRNG_CPU_FULL_ENT_MULTIPLIER;
+		}
+	}
+	return data_multiplier;
+}
+
+/*
+ * lrng_get_arch() - Get CPU entropy source entropy
+ *
+ * @outbuf: buffer to store entropy of size requested_bits
+ *
+ * Return:
+ * * > 0 on success where value provides the added entropy in bits
+ * *   0 if no fast source was available
+ */
+u32 lrng_get_arch(u8 *outbuf, u32 requested_bits)
+{
+	u32 ent_bits, data_multiplier = lrng_arch_multiplier();
+
+	if (data_multiplier <= 1) {
+		ent_bits = lrng_get_arch_data(outbuf, requested_bits);
+	} else {
+		ent_bits = lrng_get_arch_data_compress(outbuf, requested_bits,
+						       data_multiplier);
+	}
+
+	ent_bits = lrng_archrandom_entropylevel(ent_bits);
+	pr_debug("obtained %u bits of entropy from CPU RNG entropy source\n",
 		 ent_bits);
 	return ent_bits;
 }
+
+void lrng_arch_es_state(unsigned char *buf, size_t buflen)
+{
+	const struct lrng_drng *lrng_drng_init = lrng_drng_init_instance();
+	u32 data_multiplier = lrng_arch_multiplier();
+
+	/* Assume the lrng_drng_init lock is taken by caller */
+	snprintf(buf, buflen,
+		 "CPU ES properties:\n"
+		 " Hash for compressing data: %s\n"
+		 " Data multiplier: %u\n",
+		 (data_multiplier <= 1) ?
+			"N/A" : lrng_drng_init->crypto_cb->lrng_hash_name(),
+		 data_multiplier);
+}
diff --git a/drivers/char/lrng/lrng_es_aux.c b/drivers/char/lrng/lrng_es_aux.c
index 9a12f7f79..cd51c7311 100644
--- a/drivers/char/lrng/lrng_es_aux.c
+++ b/drivers/char/lrng/lrng_es_aux.c
@@ -59,6 +59,15 @@ static inline void lrng_set_digestsize(u32 digestsize)
 
 	atomic_set(&lrng_pool.digestsize, digestsize);
 
+	/*
+	 * Update the /proc/.../write_wakeup_threshold which must not be larger
+	 * than the digest size of the curent conditioning hash.
+	 */
+	digestsize <<= 3;
+	lrng_proc_update_max_write_thresh(digestsize);
+	if (lrng_write_wakeup_bits > digestsize)
+		lrng_write_wakeup_bits = digestsize;
+
 	/*
 	 * In case the new digest is larger than the old one, cap the available
 	 * entropy to the old message digest used to process the existing data.
@@ -134,7 +143,7 @@ lrng_pool_insert_aux_locked(const u8 *inbuf, u32 inbuflen, u32 entropy_bits)
 
 	entropy_bits = min_t(u32, entropy_bits, inbuflen << 3);
 
-	read_lock_irqsave(&drng->hash_lock, flags);
+	lrng_hash_lock(drng, &flags);
 
 	crypto_cb = drng->crypto_cb;
 	hash = drng->hash;
@@ -160,7 +169,7 @@ lrng_pool_insert_aux_locked(const u8 *inbuf, u32 inbuflen, u32 entropy_bits)
 			 crypto_cb->lrng_hash_digestsize(hash) << 3));
 
 out:
-	read_unlock_irqrestore(&drng->hash_lock, flags);
+	lrng_hash_unlock(drng, flags);
 	return ret;
 }
 
@@ -181,7 +190,7 @@ int lrng_pool_insert_aux(const u8 *inbuf, u32 inbuflen, u32 entropy_bits)
 
 /************************* Get data from entropy pool *************************/
 
-/**
+/*
  * Get auxiliary entropy pool and its entropy content for seed buffer.
  * Caller must hold lrng_pool.pool->lock.
  * @outbuf: buffer to store data in with size requested_bits
@@ -203,7 +212,7 @@ static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 	if (unlikely(!pool->initialized))
 		return 0;
 
-	read_lock_irqsave(&drng->hash_lock, flags);
+	lrng_hash_lock(drng, &flags);
 
 	crypto_cb = drng->crypto_cb;
 	hash = drng->hash;
@@ -250,7 +259,7 @@ static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 		memcpy(outbuf, aux_output, requested_bits >> 3);
 	}
 
-	read_unlock_irqrestore(&drng->hash_lock, flags);
+	lrng_hash_unlock(drng, flags);
 	memzero_explicit(aux_output, digestsize);
 	return returned_ent_bits;
 }
@@ -272,3 +281,14 @@ void lrng_get_backtrack_aux(struct entropy_buf *entropy_buf, u32 requested_bits)
 
 	spin_unlock_irqrestore(&pool->lock, flags);
 }
+
+void lrng_aux_es_state(unsigned char *buf, size_t buflen)
+{
+	const struct lrng_drng *lrng_drng_init = lrng_drng_init_instance();
+
+	/* Assume the lrng_drng_init lock is taken by caller */
+	snprintf(buf, buflen,
+		 "Auxiliary ES properties:\n"
+		 " Hash for operating entropy pool: %s\n",
+		 lrng_drng_init->crypto_cb->lrng_hash_name());
+}
diff --git a/drivers/char/lrng/lrng_es_irq.c b/drivers/char/lrng/lrng_es_irq.c
index 675425d87..82a73b042 100644
--- a/drivers/char/lrng/lrng_es_irq.c
+++ b/drivers/char/lrng/lrng_es_irq.c
@@ -17,6 +17,16 @@
 #include "lrng_internal.h"
 #include "lrng_es_irq.h"
 
+/*
+ * Number of interrupts to be recorded to assume that DRNG security strength
+ * bits of entropy are received.
+ * Note: a value below the DRNG security strength should not be defined as this
+ *	 may imply the DRNG can never be fully seeded in case other noise
+ *	 sources are unavailable.
+ */
+#define LRNG_IRQ_ENTROPY_BITS		CONFIG_LRNG_IRQ_ENTROPY_RATE
+
+
 /* Number of interrupts required for LRNG_DRNG_SECURITY_STRENGTH_BITS entropy */
 static u32 lrng_irq_entropy_bits = LRNG_IRQ_ENTROPY_BITS;
 /* Is high-resolution timer present? */
@@ -142,7 +152,7 @@ u32 lrng_gcd_analyze(u32 *history, size_t nelem)
 	return running_gcd;
 }
 
-static void jent_gcd_add_value(u32 time)
+static void lrng_gcd_add_value(u32 time)
 {
 	u32 ptr = (u32)atomic_inc_return_relaxed(&lrng_gcd_history_ptr);
 
@@ -173,7 +183,7 @@ static void jent_gcd_add_value(u32 time)
 }
 
 /* Return boolean whether LRNG identified presence of high-resolution timer */
-bool lrng_pool_highres_timer(void)
+static bool lrng_pool_highres_timer(void)
 {
 	return lrng_irq_highres_timer;
 }
@@ -197,11 +207,6 @@ static inline bool lrng_pcpu_pool_online(int cpu)
 	return per_cpu(lrng_pcpu_lock_init, cpu);
 }
 
-bool lrng_pcpu_continuous_compression_state(void)
-{
-	return lrng_pcpu_continuous_compression;
-}
-
 static void lrng_pcpu_check_compression_state(void)
 {
 	/* One pool must hold sufficient entropy for disabled compression */
@@ -230,14 +235,17 @@ static int __init lrng_init_time_source(void)
 		lrng_irq_highres_timer = true;
 		lrng_irq_entropy_bits = irq_entropy;
 	} else {
+		u32 new_entropy = irq_entropy * LRNG_IRQ_OVERSAMPLING_FACTOR;
+
 		lrng_health_disable();
 		lrng_irq_highres_timer = false;
-		lrng_irq_entropy_bits = irq_entropy *
-					LRNG_IRQ_OVERSAMPLING_FACTOR;
+		lrng_irq_entropy_bits = (irq_entropy < new_entropy) ?
+					 new_entropy : irq_entropy;
 		pr_warn("operating without high-resolution timer and applying IRQ oversampling factor %u\n",
 			LRNG_IRQ_OVERSAMPLING_FACTOR);
 		lrng_pcpu_check_compression_state();
 	}
+	mb();
 
 	return 0;
 }
@@ -300,7 +308,7 @@ u32 lrng_pcpu_avail_entropy(void)
 	return lrng_reduce_by_osr(lrng_data_to_entropy(irq));
 }
 
-/**
+/*
  * Trigger a switch of the hash implementation for the per-CPU pool.
  *
  * For each per-CPU pool, obtain the message digest with the old hash
@@ -422,7 +430,7 @@ lrng_pcpu_pool_hash_one(const struct lrng_crypto_cb *pcpu_crypto_cb,
 	return found_irqs;
 }
 
-/**
+/*
  * Hash all per-CPU pools and return the digest to be used as seed data for
  * seeding a DRNG. The caller must guarantee backtracking resistance.
  * The function will only copy as much data as entropy is available into the
@@ -454,7 +462,7 @@ u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded)
 	void *hash;
 
 	/* Lock guarding replacement of per-NUMA hash */
-	read_lock_irqsave(&drng->hash_lock, flags);
+	lrng_hash_lock(drng, &flags);
 
 	crypto_cb = drng->crypto_cb;
 	hash = drng->hash;
@@ -488,12 +496,12 @@ u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded)
 							     cpu, digest,
 							     &digestsize);
 		} else {
-			read_lock_irqsave(&pcpu_drng->hash_lock, flags2);
+			lrng_hash_lock(pcpu_drng, &flags2);
 			found_irqs =
 				lrng_pcpu_pool_hash_one(pcpu_drng->crypto_cb,
 							pcpu_drng->hash, cpu,
 							digest, &digestsize);
-			read_unlock_irqrestore(&pcpu_drng->hash_lock, flags2);
+			lrng_hash_unlock(pcpu_drng, flags2);
 		}
 
 		/* Inject the digest into the state of all per-CPU pools */
@@ -541,7 +549,7 @@ u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded)
 
 out:
 	crypto_cb->lrng_hash_desc_zero(shash);
-	read_unlock_irqrestore(&drng->hash_lock, flags);
+	lrng_hash_unlock(drng, flags);
 	memzero_explicit(digest, sizeof(digest));
 	return returned_ent_bits;
 
@@ -568,7 +576,7 @@ static inline void lrng_pcpu_array_compress(void)
 	if (lrng_drng && lrng_drng[node])
 		drng = lrng_drng[node];
 
-	read_lock_irqsave(&drng->hash_lock, flags);
+	lrng_hash_lock(drng, &flags);
 	crypto_cb = drng->crypto_cb;
 	hash = drng->hash;
 
@@ -595,7 +603,7 @@ static inline void lrng_pcpu_array_compress(void)
 	}
 
 	spin_unlock_irqrestore(lock, flags2);
-	read_unlock_irqrestore(&drng->hash_lock, flags);
+	lrng_hash_unlock(drng, flags);
 }
 
 /* Compress data array into hash */
@@ -664,7 +672,7 @@ static inline void _lrng_pcpu_array_add_u32(u32 data)
 	/* MSB of data go into previous unit */
 	pre_array = lrng_data_idx2array(pre_ptr);
 	/* zeroization of slot to ensure the following OR adds the data */
-	this_cpu_and(lrng_pcpu_array[pre_array], ~(0xffffffff &~ mask));
+	this_cpu_and(lrng_pcpu_array[pre_array], ~(0xffffffff & ~mask));
 	this_cpu_or(lrng_pcpu_array[pre_array], data & ~mask);
 
 	/* Invoke compression as we just filled data array completely */
@@ -742,7 +750,7 @@ static inline void lrng_time_process(void)
 	if (unlikely(!lrng_gcd_tested())) {
 		/* When GCD is unknown, we process the full time stamp */
 		lrng_time_process_common(now_time, _lrng_pcpu_array_add_u32);
-		jent_gcd_add_value(now_time);
+		lrng_gcd_add_value(now_time);
 	} else {
 		/* GCD is known and applied */
 		lrng_time_process_common((now_time / lrng_gcd_timer) &
@@ -794,3 +802,22 @@ void add_interrupt_randomness(int irq, int irq_flg)
 	}
 }
 EXPORT_SYMBOL(add_interrupt_randomness);
+
+void lrng_irq_es_state(unsigned char *buf, size_t buflen)
+{
+	const struct lrng_drng *lrng_drng_init = lrng_drng_init_instance();
+
+	/* Assume the lrng_drng_init lock is taken by caller */
+	snprintf(buf, buflen,
+		 "IRQ ES properties:\n"
+		 " Hash for operating entropy pool: %s\n"
+		 " per-CPU interrupt collection size: %u\n"
+		 " Standards compliance: %s\n"
+		 " High-resolution timer: %s\n"
+		 " Continuous compression: %s\n",
+		 lrng_drng_init->crypto_cb->lrng_hash_name(),
+		 LRNG_DATA_NUM_VALUES,
+		 lrng_sp80090b_compliant() ? "SP800-90B " : "",
+		 lrng_pool_highres_timer() ? "true" : "false",
+		 lrng_pcpu_continuous_compression ? "true" : "false");
+}
diff --git a/drivers/char/lrng/lrng_es_jent.c b/drivers/char/lrng/lrng_es_jent.c
index e98152b4c..2ed221cc9 100644
--- a/drivers/char/lrng/lrng_es_jent.c
+++ b/drivers/char/lrng/lrng_es_jent.c
@@ -45,7 +45,7 @@ static int __init lrng_jent_initialize(void)
 }
 device_initcall(lrng_jent_initialize);
 
-/**
+/*
  * lrng_get_jent() - Get Jitter RNG entropy
  *
  * @outbuf: buffer to store entropy
@@ -64,7 +64,7 @@ u32 lrng_get_jent(u8 *outbuf, u32 requested_bits)
 
 	spin_lock_irqsave(&lrng_jent_lock, flags);
 
-	if (!ent_bits || !lrng_jent_initialized) {
+	if (!lrng_jent_initialized) {
 		spin_unlock_irqrestore(&lrng_jent_lock, flags);
 		return 0;
 	}
@@ -88,3 +88,10 @@ u32 lrng_jent_entropylevel(u32 requested_bits)
 	return lrng_fast_noise_entropylevel((lrng_jent_initialized) ?
 					    jitterrng : 0, requested_bits);
 }
+
+void lrng_jent_es_state(unsigned char *buf, size_t buflen)
+{
+	snprintf(buf, buflen,
+		 "Jitter RNG ES properties:\n"
+		 " Enabled: %s\n", lrng_jent_initialized ? "true" : "false");
+}
diff --git a/drivers/char/lrng/lrng_es_mgr.c b/drivers/char/lrng/lrng_es_mgr.c
index d0d66ff36..c0025ad2b 100644
--- a/drivers/char/lrng/lrng_es_mgr.c
+++ b/drivers/char/lrng/lrng_es_mgr.c
@@ -8,14 +8,12 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <asm/irq_regs.h>
-#include <linux/lrng.h>
 #include <linux/percpu.h>
 #include <linux/random.h>
 #include <linux/utsname.h>
 #include <linux/workqueue.h>
 
 #include "lrng_internal.h"
-#include "lrng_es_irq.h"
 
 struct lrng_state {
 	bool can_invalidate;		/* Can invalidate batched entropy? */
@@ -197,7 +195,7 @@ u32 lrng_avail_entropy(void)
 	       lrng_jent_entropylevel(ent_thresh);
 }
 
-/**
+/*
  * lrng_init_ops() - Set seed stages of LRNG
  *
  * Set the slow noise source reseed trigger threshold. The initial threshold
@@ -297,7 +295,7 @@ int __init rand_initialize(void)
 	return 0;
 }
 
-/* Hot code path during boot - mix data into entropy pool during boot */
+/* Interface requesting a reseed of the DRNG */
 void lrng_pool_add_entropy(void)
 {
 	/*
@@ -320,7 +318,7 @@ void lrng_pool_add_entropy(void)
 	if (lrng_pool_trylock())
 		return;
 
-	/* Seed the DRNG with IRQ noise. */
+	/* Seed the DRNG with any available noise. */
 	if (lrng_state.perform_seedwork)
 		schedule_work(&lrng_state.lrng_seed_work);
 	else
diff --git a/drivers/char/lrng/lrng_interfaces.c b/drivers/char/lrng/lrng_interfaces.c
index 4b8c56849..b656aaf0c 100644
--- a/drivers/char/lrng/lrng_interfaces.c
+++ b/drivers/char/lrng/lrng_interfaces.c
@@ -29,7 +29,7 @@
  * should wake up processes which are selecting or polling on write
  * access to /dev/random.
  */
-u32 lrng_write_wakeup_bits = LRNG_WRITE_WAKEUP_ENTROPY;
+u32 lrng_write_wakeup_bits = (LRNG_WRITE_WAKEUP_ENTROPY << 3);
 
 static LIST_HEAD(lrng_ready_list);
 static DEFINE_SPINLOCK(lrng_ready_list_lock);
@@ -108,7 +108,7 @@ void lrng_debug_report_seedlevel(const char *name)
 
 /************************ LRNG kernel input interfaces ************************/
 
-/**
+/*
  * add_hwgenerator_randomness() - Interface for in-kernel drivers of true
  * hardware RNGs.
  *
@@ -137,7 +137,7 @@ void add_hwgenerator_randomness(const char *buffer, size_t count,
 }
 EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);
 
-/**
+/*
  * add_bootloader_randomness() - Handle random seed passed by bootloader.
  *
  * If the seed is trustworthy, it would be regarded as hardware RNGs. Otherwise
@@ -174,7 +174,7 @@ void add_input_randomness(unsigned int type, unsigned int code,
 }
 EXPORT_SYMBOL_GPL(add_input_randomness);
 
-/**
+/*
  * add_device_randomness() - Add device- or boot-specific data to the entropy
  * pool to help initialize it.
  *
@@ -198,7 +198,12 @@ void add_disk_randomness(struct gendisk *disk) { }
 EXPORT_SYMBOL(add_disk_randomness);
 #endif
 
-/**
+#ifndef CONFIG_LRNG_IRQ
+void add_interrupt_randomness(int irq, int irq_flg) { }
+EXPORT_SYMBOL(add_interrupt_randomness);
+#endif
+
+/*
  * del_random_ready_callback() - Delete a previously registered readiness
  * callback function.
  *
@@ -220,7 +225,7 @@ void del_random_ready_callback(struct random_ready_callback *rdy)
 }
 EXPORT_SYMBOL(del_random_ready_callback);
 
-/**
+/*
  * add_random_ready_callback() - Add a callback function that will be invoked
  * when the DRNG is fully initialized and seeded.
  *
@@ -264,7 +269,7 @@ EXPORT_SYMBOL(add_random_ready_callback);
 
 /*********************** LRNG kernel output interfaces ************************/
 
-/**
+/*
  * get_random_bytes() - Provider of cryptographic strong random numbers for
  * kernel-internal usage.
  *
@@ -281,7 +286,7 @@ void get_random_bytes(void *buf, int nbytes)
 }
 EXPORT_SYMBOL(get_random_bytes);
 
-/**
+/*
  * get_random_bytes_full() - Provider of cryptographic strong random numbers
  * for kernel-internal usage.
  *
@@ -300,7 +305,7 @@ void get_random_bytes_full(void *buf, int nbytes)
 }
 EXPORT_SYMBOL(get_random_bytes_full);
 
-/**
+/*
  * wait_for_random_bytes() - Wait for the LRNG to be seeded and thus
  * guaranteed to supply cryptographically secure random numbers.
  *
@@ -322,7 +327,7 @@ int wait_for_random_bytes(void)
 }
 EXPORT_SYMBOL(wait_for_random_bytes);
 
-/**
+/*
  * get_random_bytes_arch() - This function will use the architecture-specific
  * hardware random number generator if it is available.
  *
@@ -475,8 +480,10 @@ static __poll_t lrng_random_poll(struct file *file, poll_table *wait)
 	if (lrng_state_operational())
 		mask |= EPOLLIN | EPOLLRDNORM;
 	if (lrng_need_entropy() ||
-	    lrng_state_exseed_allow(lrng_noise_source_user))
+	    lrng_state_exseed_allow(lrng_noise_source_user)) {
+		lrng_state_exseed_set(lrng_noise_source_user, false);
 		mask |= EPOLLOUT | EPOLLWRNORM;
+	}
 	return mask;
 }
 
@@ -571,7 +578,6 @@ static long lrng_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
 			return -EFAULT;
 		if (size < 0)
 			return -EINVAL;
-		lrng_state_exseed_set(lrng_noise_source_user, false);
 		/* there cannot be more entropy than data */
 		ent_count_bits = min(ent_count_bits, size<<3);
 		return lrng_drng_write_common((const char __user *)p, size,
diff --git a/drivers/char/lrng/lrng_internal.h b/drivers/char/lrng/lrng_internal.h
index a21e5be71..d67aa3c33 100644
--- a/drivers/char/lrng/lrng_internal.h
+++ b/drivers/char/lrng/lrng_internal.h
@@ -11,6 +11,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#include <linux/rwlock.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 
@@ -20,6 +21,9 @@
 #define LRNG_DRNG_SECURITY_STRENGTH_BYTES 32
 #define LRNG_DRNG_SECURITY_STRENGTH_BITS (LRNG_DRNG_SECURITY_STRENGTH_BYTES * 8)
 #define LRNG_DRNG_BLOCKSIZE 64		/* Maximum of DRNG block sizes */
+#define LRNG_DRNG_INIT_SEED_SIZE_BITS (LRNG_DRNG_SECURITY_STRENGTH_BITS +      \
+				       CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS)
+#define LRNG_DRNG_INIT_SEED_SIZE_BYTES (LRNG_DRNG_INIT_SEED_SIZE_BITS >> 3)
 
 /*
  * SP800-90A defines a maximum request size of 1<<16 bytes. The given value is
@@ -53,17 +57,6 @@
  */
 #define LRNG_DRNG_MAX_WITHOUT_RESEED	(1<<30)
 
-/*
- * Number of interrupts to be recorded to assume that DRNG security strength
- * bits of entropy are received.
- * Note: a value below the DRNG security strength should not be defined as this
- *	 may imply the DRNG can never be fully seeded in case other noise
- *	 sources are unavailable.
- *
- * This value is allowed to be changed.
- */
-#define LRNG_IRQ_ENTROPY_BITS		CONFIG_LRNG_IRQ_ENTROPY_RATE
-
 /*
  * Min required seed entropy is 128 bits covering the minimum entropy
  * requirement of SP800-131A and the German BSI's TR02102.
@@ -130,8 +123,10 @@ void lrng_cc20_init_state(struct chacha20_state *state);
 
 #ifdef CONFIG_SYSCTL
 void lrng_pool_inc_numa_node(void);
+void lrng_proc_update_max_write_thresh(u32 new_digestsize);
 #else
 static inline void lrng_pool_inc_numa_node(void) { }
+static inline void lrng_proc_update_max_write_thresh(u32 new_digestsize) { }
 #endif
 
 /****************************** LRNG interfaces *******************************/
@@ -152,10 +147,12 @@ void get_random_bytes_full(void *buf, int nbytes);
 #ifdef CONFIG_LRNG_JENT
 u32 lrng_get_jent(u8 *outbuf, u32 requested_bits);
 u32 lrng_jent_entropylevel(u32 requested_bits);
-#else /* CONFIG_CRYPTO_JITTERENTROPY */
+void lrng_jent_es_state(unsigned char *buf, size_t buflen);
+#else /* CONFIG_LRNG_JENT */
 static inline u32 lrng_get_jent(u8 *outbuf, u32 requested_bits) { return 0; }
 static inline u32 lrng_jent_entropylevel(u32 requested_bits) { return 0; }
-#endif /* CONFIG_CRYPTO_JITTERENTROPY */
+static inline void lrng_jent_es_state(unsigned char *buf, size_t buflen) { }
+#endif /* CONFIG_LRNG_JENT */
 
 /************************** CPU-based Entropy Source **************************/
 
@@ -168,12 +165,19 @@ static inline u32 lrng_fast_noise_entropylevel(u32 ent_bits, u32 requested_bits)
 	return ent_bits;
 }
 
+#ifdef CONFIG_LRNG_CPU
 u32 lrng_get_arch(u8 *outbuf, u32 requested_bits);
 u32 lrng_archrandom_entropylevel(u32 requested_bits);
+void lrng_arch_es_state(unsigned char *buf, size_t buflen);
+#else /* CONFIG_LRNG_CPU */
+static inline u32 lrng_get_arch(u8 *outbuf, u32 requested_bits) { return 0; }
+static inline u32 lrng_archrandom_entropylevel(u32 requested_bits) { return 0; }
+static inline void lrng_arch_es_state(unsigned char *buf, size_t buflen) { }
+#endif /* CONFIG_LRNG_CPU */
 
 /************************** Interrupt Entropy Source **************************/
 
-bool lrng_pcpu_continuous_compression_state(void);
+#ifdef CONFIG_LRNG_IRQ
 void lrng_pcpu_reset(void);
 u32 lrng_pcpu_avail_pool_size(void);
 u32 lrng_pcpu_avail_entropy(void);
@@ -183,6 +187,25 @@ int lrng_pcpu_switch_hash(int node,
 u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded);
 void lrng_pcpu_array_add_u32(u32 data);
 u32 lrng_gcd_analyze(u32 *history, size_t nelem);
+void lrng_irq_es_state(unsigned char *buf, size_t buflen);
+#else /* CONFIG_LRNG_IRQ */
+static inline void lrng_pcpu_reset(void) { }
+static inline u32 lrng_pcpu_avail_pool_size(void) { return 0; }
+static inline u32 lrng_pcpu_avail_entropy(void) { return 0; }
+static inline int lrng_pcpu_switch_hash(int node,
+			  const struct lrng_crypto_cb *new_cb, void *new_hash,
+			  const struct lrng_crypto_cb *old_cb)
+{
+	return 0;
+}
+static inline u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits,
+				      bool fully_seeded)
+{
+	return 0;
+}
+static inline void lrng_pcpu_array_add_u32(u32 data) { }
+static inline void lrng_irq_es_state(unsigned char *buf, size_t buflen) { }
+#endif /* CONFIG_LRNG_IRQ */
 
 /****************************** DRNG processing *******************************/
 
@@ -303,18 +326,13 @@ bool lrng_state_operational(void);
 int lrng_pool_trylock(void);
 void lrng_pool_unlock(void);
 void lrng_pool_all_numa_nodes_seeded(bool set);
-bool lrng_pool_highres_timer(void);
 void lrng_pool_add_entropy(void);
 
 struct entropy_buf {
-	u8 a[LRNG_DRNG_SECURITY_STRENGTH_BYTES +
-	     (CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS >> 3)];
-	u8 b[LRNG_DRNG_SECURITY_STRENGTH_BYTES +
-	     (CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS >> 3)];
-	u8 c[LRNG_DRNG_SECURITY_STRENGTH_BYTES +
-	     (CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS >> 3)];
-	u8 d[LRNG_DRNG_SECURITY_STRENGTH_BYTES +
-	     (CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS >> 3)];
+	u8 a[LRNG_DRNG_INIT_SEED_SIZE_BYTES];
+	u8 b[LRNG_DRNG_INIT_SEED_SIZE_BYTES];
+	u8 c[LRNG_DRNG_INIT_SEED_SIZE_BYTES];
+	u8 d[LRNG_DRNG_INIT_SEED_SIZE_BYTES];
 	u32 now, a_bits, b_bits, c_bits, d_bits;
 };
 
@@ -326,6 +344,7 @@ void lrng_init_ops(struct entropy_buf *eb);
 /*********************** Auxiliary Pool Entropy Source ************************/
 
 u32 lrng_avail_aux_entropy(void);
+void lrng_aux_es_state(unsigned char *buf, size_t buflen);
 u32 lrng_get_digestsize(void);
 void lrng_pool_set_entropy(u32 entropy_bits);
 int lrng_aux_switch_hash(const struct lrng_crypto_cb *new_cb, void *new_hash,
@@ -389,6 +408,26 @@ static inline u32 atomic_read_u32(atomic_t *v)
 	return (u32)atomic_read(v);
 }
 
+/******************** Crypto Primitive Switching Support **********************/
+
+#ifdef CONFIG_LRNG_DRNG_SWITCH
+static inline void lrng_hash_lock(struct lrng_drng *drng, unsigned long *flags)
+{
+	read_lock_irqsave(&drng->hash_lock, *flags);
+}
+
+static inline void lrng_hash_unlock(struct lrng_drng *drng, unsigned long flags)
+{
+	read_unlock_irqrestore(&drng->hash_lock, flags);
+}
+#else /* CONFIG_LRNG_DRNG_SWITCH */
+static inline void lrng_hash_lock(struct lrng_drng *drng, unsigned long *flags)
+{ }
+
+static inline void lrng_hash_unlock(struct lrng_drng *drng, unsigned long flags)
+{ }
+#endif /* CONFIG_LRNG_DRNG_SWITCH */
+
 /*************************** Auxiliary functions ******************************/
 
 void invalidate_batched_entropy(void);
diff --git a/drivers/char/lrng/lrng_proc.c b/drivers/char/lrng/lrng_proc.c
index a842c6c89..b48094c32 100644
--- a/drivers/char/lrng/lrng_proc.c
+++ b/drivers/char/lrng/lrng_proc.c
@@ -12,7 +12,6 @@
 #include <linux/uuid.h>
 
 #include "lrng_internal.h"
-#include "lrng_es_irq.h"
 
 /*
  * This function is used to return both the bootid UUID, and random
@@ -80,10 +79,16 @@ static int lrng_proc_do_poolsize(struct ctl_table *table, int write,
 }
 
 static int lrng_min_write_thresh;
-static int lrng_max_write_thresh = LRNG_MAX_DIGESTSIZE;
+static int lrng_max_write_thresh = (LRNG_WRITE_WAKEUP_ENTROPY << 3);
 static char lrng_sysctl_bootid[16];
 static int lrng_drng_reseed_max_min;
 
+void lrng_proc_update_max_write_thresh(u32 new_digestsize)
+{
+	lrng_max_write_thresh = (int)new_digestsize;
+	mb();
+}
+
 struct ctl_table random_table[] = {
 	{
 		.procname	= "poolsize",
@@ -142,36 +147,45 @@ static int lrng_proc_type_show(struct seq_file *m, void *v)
 {
 	struct lrng_drng *lrng_drng_init = lrng_drng_init_instance();
 	unsigned long flags = 0;
-	unsigned char buf[390];
+	unsigned char buf[250], irq[200], aux[100], cpu[90], jent[45];
 
 	lrng_drng_lock(lrng_drng_init, &flags);
 	snprintf(buf, sizeof(buf),
 		 "DRNG name: %s\n"
-		 "Hash for reading entropy pool: %s\n"
-		 "Hash for operating aux entropy pool: %s\n"
 		 "LRNG security strength in bits: %d\n"
-		 "per-CPU interrupt collection size: %u\n"
 		 "number of DRNG instances: %u\n"
-		 "Standards compliance: %s%s\n"
-		 "High-resolution timer: %s\n"
+		 "Standards compliance: %s\n"
+		 "Entropy Sources: %s%s%sAuxiliary\n"
 		 "LRNG minimally seeded: %s\n"
-		 "LRNG fully seeded: %s\n"
-		 "Continuous compression: %s\n",
+		 "LRNG fully seeded: %s\n",
 		 lrng_drng_init->crypto_cb->lrng_drng_name(),
-		 lrng_drng_init->crypto_cb->lrng_hash_name(),
-		 lrng_drng_init->crypto_cb->lrng_hash_name(),
 		 lrng_security_strength(),
-		 LRNG_DATA_NUM_VALUES,
 		 numa_drngs,
-		 lrng_sp80090b_compliant() ? "SP800-90B " : "",
 		 lrng_sp80090c_compliant() ? "SP800-90C " : "",
-		 lrng_pool_highres_timer() ? "true" : "false",
+		 IS_ENABLED(CONFIG_LRNG_IRQ) ? "IRQ " : "",
+		 IS_ENABLED(CONFIG_LRNG_JENT) ? "JitterRNG " : "",
+		 IS_ENABLED(CONFIG_LRNG_CPU) ? "CPU " : "",
 		 lrng_state_min_seeded() ? "true" : "false",
-		 lrng_state_fully_seeded() ? "true" : "false",
-		 lrng_pcpu_continuous_compression_state() ? "true" : "false");
+		 lrng_state_fully_seeded() ? "true" : "false");
+
+	lrng_aux_es_state(aux, sizeof(aux));
+
+	irq[0] = '\0';
+	lrng_irq_es_state(irq, sizeof(irq));
+
+	jent[0] = '\0';
+	lrng_jent_es_state(jent, sizeof(jent));
+
+	cpu[0] = '\0';
+	lrng_arch_es_state(cpu, sizeof(cpu));
+
 	lrng_drng_unlock(lrng_drng_init, &flags);
 
 	seq_write(m, buf, strlen(buf));
+	seq_write(m, aux, strlen(aux));
+	seq_write(m, irq, strlen(irq));
+	seq_write(m, jent, strlen(jent));
+	seq_write(m, cpu, strlen(cpu));
 
 	return 0;
 }
diff --git a/drivers/char/lrng/lrng_selftest.c b/drivers/char/lrng/lrng_selftest.c
index e219f7ea8..4412ebd2a 100644
--- a/drivers/char/lrng/lrng_selftest.c
+++ b/drivers/char/lrng/lrng_selftest.c
@@ -30,7 +30,6 @@
 
 #include "lrng_chacha20.h"
 #include "lrng_internal.h"
-#include "lrng_es_irq.h"
 
 #define LRNG_SELFTEST_PASSED		0
 #define LRNG_SEFLTEST_ERROR_TIME	(1 << 0)
@@ -39,23 +38,12 @@
 #define LRNG_SEFLTEST_ERROR_GCD		(1 << 3)
 #define LRNG_SELFTEST_NOT_EXECUTED	0xffffffff
 
-static u32 lrng_data_selftest_ptr = 0;
-static u32 lrng_data_selftest[LRNG_DATA_ARRAY_SIZE];
-
-static unsigned int lrng_selftest_status = LRNG_SELFTEST_NOT_EXECUTED;
-
-static inline void lrng_selftest_bswap32(u32 *ptr, u32 words)
-{
-	u32 i;
+#ifdef CONFIG_LRNG_IRQ
 
-	/* Byte-swap data which is an LE representation */
-	for (i = 0; i < words; i++) {
-		__le32 *p = (__le32 *)ptr;
+#include "lrng_es_irq.h"
 
-		*p = cpu_to_le32(*ptr);
-		ptr++;
-	}
-}
+static u32 lrng_data_selftest_ptr = 0;
+static u32 lrng_data_selftest[LRNG_DATA_ARRAY_SIZE];
 
 static inline void lrng_data_process_selftest_insert(u32 time)
 {
@@ -87,7 +75,7 @@ static inline void lrng_data_process_selftest_u32(u32 data)
 	/* MSB of data go into previous unit */
 	pre_array = lrng_data_idx2array(pre_ptr);
 	/* zeroization of slot to ensure the following OR adds the data */
-	lrng_data_selftest[pre_array] &= ~(0xffffffff &~ mask);
+	lrng_data_selftest[pre_array] &= ~(0xffffffff & ~mask);
 	lrng_data_selftest[pre_array] |= data & ~mask;
 
 	/* LSB of data go into current unit */
@@ -147,6 +135,49 @@ static unsigned int lrng_data_process_selftest(void)
 	return LRNG_SEFLTEST_ERROR_TIME;
 }
 
+static unsigned int lrng_gcd_selftest(void)
+{
+	u32 history[10];
+	unsigned int i;
+
+#define LRNG_GCD_SELFTEST 3
+	for (i = 0; i < ARRAY_SIZE(history); i++)
+		history[i] = i * LRNG_GCD_SELFTEST;
+
+	if (lrng_gcd_analyze(history, ARRAY_SIZE(history)) == LRNG_GCD_SELFTEST)
+		return LRNG_SELFTEST_PASSED;
+
+	pr_err("LRNG GCD self-test FAILED\n");
+	return LRNG_SEFLTEST_ERROR_GCD;
+}
+
+#else /* CONFIG_LRNG_IRQ */
+
+static unsigned int lrng_data_process_selftest(void)
+{
+	return LRNG_SELFTEST_PASSED;
+}
+
+static unsigned int lrng_gcd_selftest(void)
+{
+	return LRNG_SELFTEST_PASSED;
+}
+
+#endif /* CONFIG_LRNG_IRQ */
+
+static inline void lrng_selftest_bswap32(u32 *ptr, u32 words)
+{
+	u32 i;
+
+	/* Byte-swap data which is an LE representation */
+	for (i = 0; i < words; i++) {
+		__le32 *p = (__le32 *)ptr;
+
+		*p = cpu_to_le32(*ptr);
+		ptr++;
+	}
+}
+
 /* The test vectors are taken from crypto/testmgr.h */
 static unsigned int lrng_hash_selftest(void)
 {
@@ -307,21 +338,7 @@ static unsigned int lrng_chacha20_drng_selftest(void)
 	return LRNG_SEFLTEST_ERROR_CHACHA20;
 }
 
-static unsigned int lrng_gcd_selftest(void)
-{
-	u32 history[10];
-	unsigned int i;
-
-#define LRNG_GCD_SELFTEST 3
-	for (i = 0; i < ARRAY_SIZE(history); i++)
-		history[i] = i * LRNG_GCD_SELFTEST;
-
-	if (lrng_gcd_analyze(history, ARRAY_SIZE(history)) == LRNG_GCD_SELFTEST)
-		return LRNG_SELFTEST_PASSED;
-
-	pr_err("LRNG GCD self-test FAILED\n");
-	return LRNG_SEFLTEST_ERROR_GCD;
-}
+static unsigned int lrng_selftest_status = LRNG_SELFTEST_NOT_EXECUTED;
 
 static int lrng_selftest(void)
 {
diff --git a/drivers/char/lrng/lrng_switch.c b/drivers/char/lrng/lrng_switch.c
index f3b2f30d1..5fce40149 100644
--- a/drivers/char/lrng/lrng_switch.c
+++ b/drivers/char/lrng/lrng_switch.c
@@ -179,7 +179,7 @@ static int lrng_drngs_switch(const struct lrng_crypto_cb *cb)
 	return 0;
 }
 
-/**
+/*
  * lrng_set_drng_cb - Register new cryptographic callback functions for DRNG
  * The registering implies that all old DRNG states are replaced with new
  * DRNG states.
diff --git a/include/linux/lrng.h b/include/linux/lrng.h
index e9dc860a1..3e8f93b53 100644
--- a/include/linux/lrng.h
+++ b/include/linux/lrng.h
@@ -10,7 +10,7 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 
-/**
+/*
  * struct lrng_crypto_cb - cryptographic callback functions
  * @lrng_drng_name		Name of DRNG
  * @lrng_hash_name		Name of Hash used for reading entropy pool
-- 
2.33.1.711.g9d530dc002

